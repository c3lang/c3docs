<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Standard Library - C3 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Standard Library";
    var mkdocs_page_input_path = "standard_library.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/ebnf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bnf.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> C3 Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">About C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Installing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../setup/">Setup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../firstproject/">Your first project</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../primer/">A quick primer on C3</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../allfeatures/">Feature list</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Documentation</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../changesfromc/">Changes from C</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compare/">Comparisons with other languages</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../types/">Types</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../define/">Define</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../arrays/">Arrays</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../vectors/">Vectors</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../statements/">Statements</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../expressions/">Expressions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../optionals/">Optionals and error handling</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compiletime/">Compile time evaluation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../contracts/">Contracts</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../generics/">Generics</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../macros/">Macros</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../reflection/">Reflection</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../operators/">Operator overloading</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../anyinterfaces/">Any and protocols</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../undefinedbehaviour/">Undefined behaviour</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../conversion/">Conversions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../precedence/">Precedence</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../builtins/">Builtins</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../libraries/">Libraries</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Standard Library</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#stdcorebuiltin">std::core::builtin</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#void-panicchar-message-char-file-char-function-uint-line">void panic(char message, char file, char *function, uint line)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-swapa-b">void @swap(&amp;a, &amp;b)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#varcastany-v-type">varcast(any* v, $Type)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-unreachablestring-unreachable-statement-reached">void unreachable($string = "Unreachable statement reached.")</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bitcastvalue-type">bitcast(value, $Type)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#enum_by_nametype-enum_name">enum_by_name($Type, enum_name)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-scope-body">void @scope(&variable; @body)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#less-greater-less_eq-greater_eq-equals">less, greater, less_eq, greater_eq, equals</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#faults">Faults</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#stdcoreenv">std::core::env</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#constants">Constants</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#stdcoremem">std::core::mem</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#malloc-malloc_checked-malloc_aligned">malloc, malloc_checked, malloc_aligned</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#malloctype-malloctype-usz-elements">malloc($Type), malloc($Type, usz elements)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#calloc-calloc_checked-calloc_aligned">calloc, calloc_checked, calloc_aligned</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#relloc-relloc_checked-realloc_aligned">relloc, relloc_checked, realloc_aligned</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#free-free_aligned">free, free_aligned</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#scopedallocator-allocator-body">@scoped(Allocator* allocator; @body())</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tscoped-body">@tscoped(; @body())</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-tmallocusz-size-usz-alignment-0">void* tmalloc(usz size, usz alignment = 0)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-tcallocusz-size-usz-alignment-0">void* tcalloc(usz size, usz alignment = 0)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-treallocvoid-ptr-usz-size-usz-alignment-0">void trealloc(void ptr, usz size, usz alignment = 0)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-poolbody">void @pool(;@body)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#volatile_loadx">@volatile_load(&amp;x)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#volatile_storex-y">@volatile_store(&amp;x, y)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#usz-aligned_offsetusz-offset-usz-alignment">usz aligned_offset(usz offset, usz alignment)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#usz-aligned_pointervoid-ptr-usz-alignment">usz aligned_pointer(void* ptr, usz alignment)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bool-ptr_is_alignedvoid-ptr-usz-alignment">bool ptr_is_aligned(void* ptr, usz alignment)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-copyvoid-dst-void-src-usz-len-usz-dst_align-0-usz-src_align-0-bool-is_volatile-false">void copy(void dst, void src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-setvoid-dst-char-val-usz-len-usz-dst_align-0-bool-is_volatile-false">void set(void* dst, char val, usz len, usz $dst_align = 0, bool $is_volatile = false)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-clearvoid-dst-usz-len-usz-dst_align-0-bool-is_volatile-false">void clear(void* dst, usz len, usz $dst_align = 0, bool $is_volatile = false)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#clonevalue">@clone(&amp;value)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tclonevalue">@tclone(&amp;value)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#stdcoretypes">std::core::types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#bool-is_comparabletype">bool is_comparable($Type)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bool-is_equatable_valuevalue">bool is_equatable_value(value)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bool-is_equatable_valuevalue_1">bool is_equatable_value(value)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#kind_is_inttypekind-kind">kind_is_int(TypeKind kind)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#any_to_intany-v-type">any_to_int(any* v, $Type)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#stdcorestrconv">std::core::str::conv</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#usz-char32_to_utf8char32-c-char-output-usz-available">usz! char32_to_utf8(Char32 c, char* output, usz available)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-char32_to_utf16_unsafechar32-c-char16-output">void char32_to_utf16_unsafe(Char32 c, Char16** output)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#stdio">std::io</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#usz-printfstring-format-args-maydiscard">usz! printf(String format, args...) @maydiscard</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#usz-dstringprintfdstring-str-string-format-args-maydiscard">usz! DString.printf(DString* str, String format, args...) @maydiscard</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#usz-fileprintffile-file-string-format-args-maydiscard">usz! File.printf(File file, String format, args...) @maydiscard</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-fileopenfile-file-string-filename-string-mode">void! File.open(File* file, String filename, String mode)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-fileseekfile-file-long-offset-seek-seekmode-seekset">void! File.seek(File *file, long offset, Seek seekMode = Seek.SET)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-fileclosefile-file-inline">void! File.close(File *file) @inline</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bool-fileeoffile-file-inline">bool File.eof(File* file) @inline</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-fileputcfile-file-char-c">void! File.putc(File *file, char c)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#usz-filereadfile-file-void-buffer-usz-items-usz-element_size-1">usz File.read(File file, void buffer, usz items, usz element_size = 1)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#usz-filewritefile-file-void-buffer-usz-items-usz-element_size-1">usz File.write(File file, void buffer, usz items, usz element_size = 1)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#stdout-stdin-stderr">stdout(), stdin(), stderr()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#stdcollectionslist">std::collections::list()</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#listpushlist-list-type-element-append">List.push(List *list, Type element), append(...)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-listpoplist-list">Type List.pop(List* list)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-listpop_firstlist-list">Type List.pop_first(List *list)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-listremove_atlist-list-usz-index">void List.remove_at(List *list, usz index)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-listinsert_atlist-list-usz-index-type-type">void List.insert_at(List *list, usz index, Type type)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-listpush_frontlist-list-type-type">void List.push_front(List *list, Type type)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-listremove_lastlist-list">void List.remove_last(List* list)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-listremove_firstlist-list">void List.remove_first(List *list)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-listfirstlist-list">Type List.first(List list)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-listlastlist-list">Type List.last(List list)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#listis_emptylist-list">List.is_empty(List *list)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#usz-listlenlist-list">usz List.len(List *list)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-listgetlist-list-usz-index">Type List.get(List *list, usz index)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-listfreelist-list">void List.free(List *list)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#void-listswaplist-list-usz-i-usz-j">void List.swap(List *list, usz i, usz j)</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ideas/">More ideas</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../naming/">Naming rules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../comments/">Comments & Docs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../attributes/">Attributes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../asm/">Inline asm</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cinterop/">C Interop</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../syntax/">Grammar</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../sample/">More code examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../specification/">Specification</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Build system</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../buildintro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../project/">Project Structure</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../buildcommands/">Commands</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Development</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../contribute/">Contribute</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../changes/">Changes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../rejectedideas/">Rejected ideas</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">C3 Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Documentation &raquo;</li>
        
      
    
    <li>Standard Library</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="library">Library</h1>
<p>The standard library is currently in development, so frequent changes will occur. Note that all std::core modules and
sub modules are implicitly imported.</p>
<h2 id="stdcorebuiltin">std::core::builtin</h2>
<p>All functions and macros in this library can be used without path qualifiers.</p>
<h3 id="void-panicchar-message-char-file-char-function-uint-line">void panic(char<em> message, char </em>file, char *function, uint line)</h3>
<p>Default function called when the asserts fails.</p>
<h3 id="void-swapa-b">void @swap(&amp;a, &amp;b)</h3>
<p>Swap values in <code>a</code> and <code>b</code>.</p>
<pre><code class="language-c">int a = 3;
int b = 5;
@swap(a, b);
io::printfn(&quot;%d&quot;, a); // Prints 5
</code></pre>
<h3 id="varcastany-v-type">varcast(any* v, $Type)</h3>
<p>Optionally cast the value <code>v</code> to type <code>$Type*</code> on failure returns <code>VarCastResult.TYPE_MISMATCH</code>.</p>
<pre><code class="language-c">int b;
any* a = &amp;b;
float*! c = varcast(a, float); // Will return TYPE_MISMATCH
int*! d = varcast(a, int);     // Works!
</code></pre>
<h3 id="void-unreachablestring-unreachable-statement-reached">void unreachable($string = "Unreachable statement reached.")</h3>
<p>Mark a code path as unreachable.</p>
<pre><code class="language-c">switch (x)
{
  case 0:
    foo();
  case 1:
    bar();
  default:
    // Should never happen.
    unreachable(&quot;x should have been 0 or 1&quot;);    
}    
</code></pre>
<p>On safe mode this will throw a runtime panic when reached. For release mode the
compiler will assume this case never happens.</p>
<h3 id="bitcastvalue-type">bitcast(value, $Type)</h3>
<p>Do a bitcast of a value to <code>$Type</code>, requires that the types are of the same memory size.</p>
<pre><code class="language-c">float x = 1.0;
int y = bitcast(x, int); // y = 0x3f800000
</code></pre>
<h3 id="enum_by_nametype-enum_name">enum_by_name($Type, enum_name)</h3>
<p>Optionally returns the enum value with the given name. <code>$Type</code> must be an enum. Returns <code>SearchResult.MISSING</code>
on failure.</p>
<pre><code class="language-c">enum Foo { ABC, CDE, EFG }

fn void! test()
{
  Foo f = enum_by_name(Foo, &quot;CDE&quot;)!; 
  // same as Foo f = Foo.CDE;
}
</code></pre>
<h3 id="void-scope-body">void @scope(&variable; @body)</h3>
<p>Scopes a variable:</p>
<pre><code>int a = 3;

@scope(a)
{
    a = 4;
    a++;
};

// Prints a = 3
io::printfn(&quot;a = %d&quot;, a, b);
</code></pre>
<h3 id="less-greater-less_eq-greater_eq-equals">less, greater, less_eq, greater_eq, equals</h3>
<p>All macros take two values and compare them. Any type implementing <code>Type.less</code> 
or <code>Type.compare_to</code> may be compared (or if the type implements <code>&lt;</code>). Types 
implementing <code>Type.equals</code> may use <code>equals</code> even if neither <code>less</code> nor <code>compare_to</code>
are implemented.</p>
<h3 id="faults">Faults</h3>
<ul>
<li><code>IteratorResult</code> returned when reaching the end of an iterator.</li>
<li><code>SearchResult</code> used when a search fails.</li>
<li><code>AnyCastResult</code> when a any cast fails.</li>
</ul>
<h2 id="stdcoreenv">std::core::env</h2>
<h3 id="constants">Constants</h3>
<ul>
<li><code>OS_TYPE</code> the OS type compiled for.</li>
<li><code>COMPILER_OPT_LEVEL</code> the optimization level used.</li>
<li><code>I128_SUPPORT</code> true if int128 support is available.</li>
<li><code>COMPILER_SAFE_MODE</code> true if compiled with safety checks.</li>
</ul>
<h2 id="stdcoremem">std::core::mem</h2>
<h3 id="malloc-malloc_checked-malloc_aligned">malloc, malloc_checked, malloc_aligned</h3>
<p>Allocate the given number of bytes. <code>malloc</code> will panic on out of memory, 
whereas <code>malloc_checked</code> and <code>malloc_aligned</code> returns an optional value.
<code>malloc_aligned</code> adds an alignment, which must be a power of 2. Any pointer
allocated using <code>malloc_aligned</code> must be freed using <code>free_aligned</code> rather
the normal <code>free</code> or memory corruption may result.</p>
<p>These calls takes an optional <code>using</code> parameter, replacing the default
allocator with a custom one.</p>
<pre><code class="language-c">char* data = malloc(8);
char*! data2 = malloc_checked(8);
int[&lt;16&gt;]*! data3 = malloc_aligned(16 * int.sizeof), 128);
char* data2 = malloc(8, .using = my_allocator);  
</code></pre>
<h3 id="malloctype-malloctype-usz-elements">malloc($Type), malloc($Type, usz elements)</h3>
<p>The first form allocates a single element of $Type, returning the pointer,
the second form allocates a slice with <code>elements</code> number of elements, returning
a subarray of the given length. Elements are not initialized.</p>
<pre><code class="language-c">int* int = malloc(int);
int[] ints = malloc(int, 100); // Allocated int[100] on the heap.
</code></pre>
<p><code>malloc_checked</code> has the same two additional forms as <code>malloc</code> but the
return is optional.</p>
<p>Both <code>malloc</code> variants has the same optional <code>using</code> parameter, but also 
supports <code>end_padding</code> to provide extra allocation space after the regular allocation.</p>
<pre><code class="language-c">struct Abc
{
    int header;
    char[*] data;
}

...

// Allocate a &quot;Type&quot; but add &quot;data_len&quot; bytes
// for the flexible array member &quot;data&quot;:
Type* t = malloc(Abc, .end_padding = data_len);
</code></pre>
<h3 id="calloc-calloc_checked-calloc_aligned">calloc, calloc_checked, calloc_aligned</h3>
<p>Identical to the <code>malloc</code> variants, except the data is guaranteed to be zeroed out.</p>
<h3 id="relloc-relloc_checked-realloc_aligned">relloc, relloc_checked, realloc_aligned</h3>
<p>Resizes memory allocated using <code>malloc</code> or <code>calloc</code>. Any extra data is 
guaranteed to be zeroed out. <code>realloc_aligned</code> can only be used with
pointers created using <code>calloc_aligned</code> or <code>alloc_aligned</code>.</p>
<h3 id="free-free_aligned">free, free_aligned</h3>
<p>Frees memory allocated using <code>malloc</code> or <code>calloc</code>. Any memory allocated using "_aligned" variants
must be freed using <code>free_aligned</code>.</p>
<h3 id="scopedallocator-allocator-body">@scoped(Allocator* allocator; @body())</h3>
<p>Swaps the current memory allocator for the duration of the call.</p>
<pre><code class="language-c">DynamicArenaAllocator dynamic_arena;
dynamic_arena.init(1024);
mem::@scoped(&amp;dynamic_arena) 
{
    // This allocation uses the dynamic arena 
    Foo* f = malloc(Foo);
};
// Release any dynamic arena memory.
dynamic_arena.destroy();    

</code></pre>
<h3 id="tscoped-body">@tscoped(; @body())</h3>
<p>Same as @scoped, but uses the temporary allocator rather than any
arbitrary allocator.</p>
<h3 id="void-tmallocusz-size-usz-alignment-0">void* tmalloc(usz size, usz alignment = 0)</h3>
<p>Allocates memory using the temporary allocator. Panic on failure. It has type
variants similar to <code>malloc</code>, so <code>tmalloc(Type)</code> would create a <code>Type*</code> using
the temporary allocator.</p>
<h3 id="void-tcallocusz-size-usz-alignment-0">void* tcalloc(usz size, usz alignment = 0)</h3>
<p>Same as <code>tmalloc</code> but clears the memory.</p>
<h3 id="void-treallocvoid-ptr-usz-size-usz-alignment-0">void<em> trealloc(void</em> ptr, usz size, usz alignment = 0)</h3>
<p><code>realloc</code> but on memory received using <code>tcalloc</code> or <code>tmalloc</code>.</p>
<h3 id="void-poolbody">void @pool(;@body)</h3>
<p>Opens a temporary memory scope.</p>
<pre><code class="language-c">@poo() 
{
    // This allocation uses the dynamic arena 
    Foo* f = talloc(Foo);
};

</code></pre>
<h3 id="volatile_loadx">@volatile_load(&amp;x)</h3>
<p>Returns the value in <code>x</code> using a volatile load.</p>
<pre><code class="language-c">// Both loads will always happen:
int y = @volatile_load(my_global);
y = @volatile_load(my_global);
</code></pre>
<h3 id="volatile_storex-y">@volatile_store(&amp;x, y)</h3>
<p>Store the value <code>y</code> in <code>x</code> using a volatile store.</p>
<pre><code class="language-c">// Both stores will always happen:
@volatile_store(y, 1);
@volatile_store(y, 1);
</code></pre>
<h3 id="usz-aligned_offsetusz-offset-usz-alignment">usz aligned_offset(usz offset, usz alignment)</h3>
<p>Returns an aligned size based on the current offset. The alignment
must be a power of two. E.g. <code>mem::aligned_offset(17, 8)</code> would return <code>24</code></p>
<h3 id="usz-aligned_pointervoid-ptr-usz-alignment">usz aligned_pointer(void* ptr, usz alignment)</h3>
<p>Returns a pointer aligned to the given alignment, using <code>aligned_offset</code>.</p>
<h3 id="bool-ptr_is_alignedvoid-ptr-usz-alignment">bool ptr_is_aligned(void* ptr, usz alignment)</h3>
<p>Return true if the pointer is aligned, false otherwise.</p>
<h3 id="void-copyvoid-dst-void-src-usz-len-usz-dst_align-0-usz-src_align-0-bool-is_volatile-false">void copy(void<em> dst, void</em> src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false)</h3>
<p>Copies bytes from one pointer to another. It may optionally be set as volatile,
in which case the copy may not be optimized away. Furthermore the source
and destination alignment may be used.</p>
<pre><code class="language-c">
Foo* f = talloc(data_size);
mem::copy(f, slice.ptr, size); 
</code></pre>
<h3 id="void-setvoid-dst-char-val-usz-len-usz-dst_align-0-bool-is_volatile-false">void set(void* dst, char val, usz len, usz $dst_align = 0, bool $is_volatile = false)</h3>
<p>Sets bytes to a value. This operation may be aligned and/or volatile. See the <code>copy</code> method.</p>
<h3 id="void-clearvoid-dst-usz-len-usz-dst_align-0-bool-is_volatile-false">void clear(void* dst, usz len, usz $dst_align = 0, bool $is_volatile = false)</h3>
<p>Sets bytes to zero. This operation may be aligned and/or volatile. See the <code>copy</code> method.</p>
<h3 id="clonevalue">@clone(&amp;value)</h3>
<p>Makes a shallow copy of a value using the regular allocator.</p>
<pre><code class="language-c">Foo f = ...

return @clone(f); 

</code></pre>
<h3 id="tclonevalue">@tclone(&amp;value)</h3>
<p>Same as <code>@clone</code> but uses the temporary allocator.</p>
<h2 id="stdcoretypes">std::core::types</h2>
<h3 id="bool-is_comparabletype">bool is_comparable($Type)</h3>
<p>Return true if the type can be used with comparison operators.</p>
<h3 id="bool-is_equatable_valuevalue">bool is_equatable_value(value)</h3>
<p>Return <code>true</code> if the value can be compared using the <code>equals</code> macro.</p>
<h3 id="bool-is_equatable_valuevalue_1">bool is_equatable_value(value)</h3>
<p>Return <code>true</code> if the value can be compared using the comparison macros.</p>
<h3 id="kind_is_inttypekind-kind">kind_is_int(TypeKind kind)</h3>
<h3 id="any_to_intany-v-type">any_to_int(any* v, $Type)</h3>
<p>Returns an optional value of <code>$Type</code> if the any value losslessly
may be converted into the given type. Returns a <code>ConversionResult</code> otherwise.</p>
<pre><code class="language-c">any* v = &amp;&amp;128;
short y = any_to_int(v, short)!!; // Works 
ichar z = any_to_int(v, ichar)!!; // Panics VALUE_OUT_OF_RANGE
</code></pre>
<h2 id="stdcorestrconv">std::core::str::conv</h2>
<h3 id="usz-char32_to_utf8char32-c-char-output-usz-available">usz! char32_to_utf8(Char32 c, char* output, usz available)</h3>
<p>Convert a UTF32 codepoint to an UTF8 buffer. <code>size</code> has the number of
writable bytes left. It returns the number of bytes used, or 
<code>UnicodeResult.CONVERSION_FAILED</code> if the buffer is too small.</p>
<h3 id="void-char32_to_utf16_unsafechar32-c-char16-output">void char32_to_utf16_unsafe(Char32 c, Char16** output)</h3>
<p>Convert a UTF32 codepoint to an UTF16 buffer without bounds checking,
moving the output pointer 1 or 2 steps.</p>
<h2 id="stdio">std::io</h2>
<h3 id="usz-printfstring-format-args-maydiscard">usz! printf(String format, args...) @maydiscard</h3>
<p>Regular printf functionality: <code>%s</code>, <code>%x</code>, <code>%d</code>, <code>%f</code> and <code>%p</code> are supported.
Will also print enums and vectors.</p>
<h3 id="usz-dstringprintfdstring-str-string-format-args-maydiscard">usz! DString.printf(DString* str, String format, args...) @maydiscard</h3>
<p>Same as printf but on dynamic strings.</p>
<h3 id="usz-fileprintffile-file-string-format-args-maydiscard">usz! File.printf(File file, String format, args...) @maydiscard</h3>
<p>Same as printf but on files.</p>
<h3 id="void-fileopenfile-file-string-filename-string-mode">void! File.open(File* file, String filename, String mode)</h3>
<p>Open a file with the given file name with the given mode (r, w etc)</p>
<h3 id="void-fileseekfile-file-long-offset-seek-seekmode-seekset">void! File.seek(File *file, long offset, Seek seekMode = Seek.SET)</h3>
<p>Seek in a file. Based on the libc function.</p>
<h3 id="void-fileclosefile-file-inline">void! File.close(File *file) @inline</h3>
<p>Close a file, based on the libc function.</p>
<h3 id="bool-fileeoffile-file-inline">bool File.eof(File* file) @inline</h3>
<p>True if EOF has been reached. Based on the libc function.</p>
<h3 id="void-fileputcfile-file-char-c">void! File.putc(File *file, char c)</h3>
<p>Write a single byte to a file. See the libc function.</p>
<h3 id="usz-filereadfile-file-void-buffer-usz-items-usz-element_size-1">usz File.read(File<em> file, void</em> buffer, usz items, usz element_size = 1)</h3>
<p>Read into a buffer, based on the libc function.</p>
<h3 id="usz-filewritefile-file-void-buffer-usz-items-usz-element_size-1">usz File.write(File<em> file, void</em> buffer, usz items, usz element_size = 1)</h3>
<p>Write to a buffer, based on the libc function.</p>
<h3 id="stdout-stdin-stderr">stdout(), stdin(), stderr()</h3>
<p>Return stdout, stdin and stderr respectively.</p>
<h2 id="stdcollectionslist">std::collections::list(<Type>)</h2>
<p>Generic list module, elements are of <code>Type</code>.</p>
<pre><code class="language-c">import std::collections::list;
def MyIntList = List(&lt;int&gt;);

...

MyIntList list;
list.push(123);
list.free();
</code></pre>
<h3 id="listpushlist-list-type-element-append">List.push(List *list, Type element), append(...)</h3>
<p>Append a single value to the list.</p>
<h3 id="type-listpoplist-list">Type List.pop(List* list)</h3>
<p>Removes and returns the last entry in the list.</p>
<h3 id="type-listpop_firstlist-list">Type List.pop_first(List *list)</h3>
<p>Removes the first entry in the list.</p>
<h3 id="void-listremove_atlist-list-usz-index">void List.remove_at(List *list, usz index)</h3>
<p>Removes the entry at <code>index</code>.</p>
<h3 id="void-listinsert_atlist-list-usz-index-type-type">void List.insert_at(List *list, usz index, Type type)</h3>
<p>Inserts a value at <code>index</code>.</p>
<h3 id="void-listpush_frontlist-list-type-type">void List.push_front(List *list, Type type)</h3>
<p>Inserts a value to the front of the list.</p>
<h3 id="void-listremove_lastlist-list">void List.remove_last(List* list)</h3>
<p>Remove the last value of the list.</p>
<h3 id="void-listremove_firstlist-list">void List.remove_first(List *list)</h3>
<p>Remove the first element in the list.</p>
<h3 id="type-listfirstlist-list">Type<em> List.first(List</em> list)</h3>
<p>Return the first element in the list if available.</p>
<h3 id="type-listlastlist-list">Type<em> List.last(List </em>list)</h3>
<p>Return the last element in the list if available.</p>
<h3 id="listis_emptylist-list">List.is_empty(List *list)</h3>
<p>Return <code>true</code> if the list is empty.</p>
<h3 id="usz-listlenlist-list">usz List.len(List *list)</h3>
<p>Return the number of elements in the list.</p>
<h3 id="type-listgetlist-list-usz-index">Type List.get(List *list, usz index)</h3>
<p>Return the value at <code>index</code>.</p>
<h3 id="void-listfreelist-list">void List.free(List *list)</h3>
<p>Free all memory associated with this list.</p>
<h3 id="void-listswaplist-list-usz-i-usz-j">void List.swap(List *list, usz i, usz j)</h3>
<p>Swap two elements in the list.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../ideas/" class="btn btn-neutral float-right" title="More ideas">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../libraries/" class="btn btn-neutral" title="Libraries"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../libraries/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../ideas/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
