<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Any and interfaces - C3 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Any and interfaces";
    var mkdocs_page_input_path = "anyinterfaces.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/ebnf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bnf.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> C3 Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">About C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Installing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../setup/">Setup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../firstproject/">Your first project</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../primer/">A quick primer on C3</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../allfeatures/">Feature list</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Documentation</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../changesfromc/">Changes from C</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compare/">Comparisons with other languages</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../types/">Types</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../define/">Define</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../arrays/">Arrays</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../vectors/">Vectors</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../statements/">Statements</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../expressions/">Expressions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../optionals/">Optionals and error handling</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compiletime/">Compile time evaluation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../contracts/">Contracts</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../generics/">Generics</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../macros/">Macros</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../reflection/">Reflection</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../operators/">Operator overloading</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Any and interfaces</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#working-with-the-type-of-any-at-runtime">Working with the type of any* at runtime.</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#interfaces">Interfaces</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#defining-an-interface">Defining an interface</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#implementing-the-interface">Implementing the interface</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dynamic-methods">"@dynamic" methods</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#referring-to-an-interface-by-pointer">Referring to an interface by pointer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#calling-dynamic-methods">Calling dynamic methods</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reflection-invocation">Reflection invocation</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#variable-argument-functions-with-implicit-any">Variable argument functions with implicit any</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#explicit-any-vararg-functions">Explicit any vararg functions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#implicit-any-vararg-functions">Implicit any vararg functions</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../undefinedbehaviour/">Undefined behaviour</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../conversion/">Conversions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../precedence/">Precedence</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../builtins/">Builtins</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../libraries/">Libraries</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../standard_library/">Standard Library</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ideas/">More ideas</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../naming/">Naming rules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../comments/">Comments & Docs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../attributes/">Attributes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../asm/">Inline asm</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cinterop/">C Interop</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../syntax/">Grammar</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../sample/">More code examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../specification/">Specification</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Build system</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../buildintro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../project/">Project Structure</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../buildcommands/">Commands</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Development</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../contribute/">Contribute</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../changes/">Changes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../rejectedideas/">Rejected ideas</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">C3 Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Documentation &raquo;</li>
        
      
    
    <li>Any and interfaces</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="any-and-interfaces">Any and interfaces</h1>
<h2 id="working-with-the-type-of-any-at-runtime">Working with the type of <code>any*</code> at runtime.</h2>
<p>The <code>any*</code> type is recommended for writing code that is polymorphic at runtime where macros are not appropriate.
It can be thought of as a typed <code>void*</code>. Note that it is a fat pointer and is two pointers wide (unlike <code>void*</code>).
It cannot be dereferenced.</p>
<p>An <code>any*</code> can be created by assigning any pointer to it. You can then query the <code>any*</code> type for the typeid of 
the enclosed type (the type the pointer points to) using the <code>type</code> field.</p>
<p>This allows switching over the typeid, either using a normal switch:</p>
<pre><code>switch (my_any.typeid)
{
    case Foo.typeid:
        ...
    case Bar.typeid:
        ...
}
</code></pre>
<p>Or the special <code>any*</code>-version of the switch:</p>
<pre><code>switch (my_any)
{
    case Foo:
        // my_any can be used as if it was Foo* here
    case Bar:
        // my_any can be used as if it was Bar* here
}
</code></pre>
<p>Sometimes one needs to manually construct an any-pointer, which
is typically done using the <code>any_make</code> function: <code>any_make(ptr, type)</code>
will create an <code>any*</code> pointing to <code>ptr</code> and with typeid <code>type</code>.</p>
<p>Since the runtime <code>typeid</code> is available, we can query for any runtime <code>typeid</code> property available
at runtime, for example the size, e.g. <code>my_any.typeid.sizeof</code>. This allows us to do a lot of work
on with the enclosed data without knowing the details of its type.</p>
<p>For example, this would make a copy of the data and place it in the variable <code>any_copy</code>:</p>
<pre><code>void* data = malloc(a.type.sizeof);
mem::copy(data, a.ptr, a.type.sizeof);
any* any_copy = any_make(data, a.type);
</code></pre>
<h2 id="interfaces">Interfaces</h2>
<p>Most statically typed object-oriented languages implements extensibility using vtables. In C, and by extension
C3, this is possible to emulate by passing around structs containing list of function pointers in addition to the data.</p>
<p>While this is efficient and often the best solution, but it puts certain assumptions on the code and makes interfaces
more challenging to evolve over time.</p>
<p>As an alternative there are languages (such as Objective-C) which instead use message passing to dynamically typed
objects, where the availability of a certain functionality may be queried at runtime.</p>
<p>C3 provides this latter functionality over the <code>any*</code> type using <em>interfaces</em>.</p>
<h3 id="defining-an-interface">Defining an interface</h3>
<p>The first step is to define an interface:</p>
<pre><code>interface MyName
{
    fn String myname();
}
</code></pre>
<p>While <code>myname</code> will behave as a method, we declare it without type. Note here that unlike normal methods we leave
out the first "self", argument.</p>
<h3 id="implementing-the-interface">Implementing the interface</h3>
<p>To declare that a type implements an interface, add it after the type name:</p>
<pre><code>struct Baz (MyName) 
{ 
    int x; 
}

// Note how the first argument differs from the interface.
fn String Baz.myname(Baz* self) @dynamic 
{ 
    return "I am Baz!"; 
}
</code></pre>
<p>If a type declares an interface but does not implement its methods, then that is compile time error. However,
methods marked <code>@optional</code> does not need to be implemented:</p>
<pre><code>protocol VeryOptional
{
    fn void test();
    fn void do_something(int x, void* ptr) @optional;
}

struct Foo (VeryOptional)
{
    int z;
}

fn void Foo.test(&amp;self) { }
</code></pre>
<p>This example is would compile, despite not implementing both functions, as the second method is marked <code>@optional</code>.</p>
<p>A type may implement multiple interfaces, by placing them all inside of <code>()</code> e.g. <code>struct Foo (VeryOptional, MyName) { ... }</code></p>
<p>A limitation is that only user-defined types may declare they are implementing interfaces. To make existing types
implement interfaces is possible but does not provide compile time checks.</p>
<p>One of the interfaces available in the standard library is Printable, which contains <code>to_format</code> and <code>to_string</code>.
If we implemented it for our struct above it might look like this:</p>
<pre><code>fn String Baz.to_string(Baz* baz, Allocator* using) @dynamic
{
    return string::printf("Baz(%d)", baz.x, .using = using);
}
</code></pre>
<h3 id="dynamic-methods">"@dynamic" methods</h3>
<p>A method must be declared <code>@dynamic</code> to implement an interface, but a method may also be declared <code>@dynamic</code> <em>without</em>
the type declaring it implements a particular interface. For example, this allows us to write:</p>
<pre><code>// This will make "int" satisfy the MyName interface
fn String int.myname(int*) @dynamic
{ 
    return "I am int!"; 
}
</code></pre>
<p><code>@dynamic</code> methods have their reference retained in the runtime code and can also be searched for at runtime and invoked
from the <code>any</code> type.</p>
<h3 id="referring-to-an-interface-by-pointer">Referring to an interface by pointer</h3>
<p>A pointer to an interface e.g. <code>MyName*</code> is can be cast back and forth to <code>any*</code>, but only types which 
implement the interface completely may implicitly be cast to the interface pointer.</p>
<p>So for example:</p>
<pre><code>Bob b = { 1 };
double d = 0.5;
int i = 3;
MyName* a = &amp;b;          // Valid, Bob implements MyName.
// MyName* c = &amp;d;       // Error, double does not implement MyName.
MyName* c = (MyName*)&amp;d; // Would break at runtime as double doesn't implement MyName
// MyName* z = &amp;i;       // Error, implicit conversion because int doesn't explicitly implement it.
MyName* z = (MyName*)&amp;i; // Explicit conversion works and is safe at runtime if int implements "myname"
</code></pre>
<h3 id="calling-dynamic-methods">Calling dynamic methods</h3>
<p>Methods implementing interfaces are like normal methods, and if called directly, they are just normal function calls. The
difference is that they may be invoked through the interface:</p>
<pre><code>fn void whoareyou(MyName* a)
{
    io::printn(a.myname());
}
</code></pre>
<p>If we have an optional method we should first check that it is implemented:</p>
<pre><code>fn void do_something(VeryOptional* z)
{
    if (&amp;z.do_something)
    {
        z.do_something(1, null);
    }
}
</code></pre>
<p>We first query if the method exists on the value. If it does we actually run it.</p>
<p>Here is another example, showing how the correct function will be called depending on type, checking
for methods on an <code>any*</code>:</p>
<pre><code>fn void whoareyou2(any* a)
{
    // Query if the function exists
    if (!&amp;a.myname)
    {
        io::printn("I don't know who I am.");
        return;
    }
    // Dynamically call the function
    io::printn(((MyName*)a).myname());
}

fn void main()
{
    int i;
    double d;
    Bob bob;

    any* a = &amp;i; 
    whoareyou2(a); // Prints "I am int!"
    a = &amp;d;
    whoareyou2(a); // Prints "I don't know who I am."
    a = &amp;bob;
    whoareyou2(a); // Prints "I am Bob!"
}
</code></pre>
<h3 id="reflection-invocation">Reflection invocation</h3>
<p><em>This functionality is not yet implemented and may see syntax changes</em></p>
<p>It is possible to retrieve any <code>@dynamic</code> function by name and invoke it:</p>
<pre><code>def VoidMethodFn = fn void(void*);

fn void* int.test_something(&amp;self) @dynamic
{
    io::printfn("Testing: %d", *self);
}

fn void main()
{
    int z = 321;
    any* a = &amp;z;
    VoidMethodFn test_func = a.reflect("test_something");
    test_func(a); // Will print "Testing: 321"
}
</code></pre>
<p>This feature allows methods to be linked up at runtime.</p>
<h2 id="variable-argument-functions-with-implicit-any">Variable argument functions with implicit <code>any</code></h2>
<p>Regular typed varargs are of a single type, e.g. <code>fn void abc(int x, double... args)</code>.
In order to take variable functions that are of multiple types, <code>any</code> may be used. 
There are two variants:</p>
<h3 id="explicit-any-vararg-functions">Explicit <code>any</code> vararg functions</h3>
<p>This type of function has a format like <code>fn void vaargfn(int x, any... args)</code>. Because only
pointers may be passed to an <code>any</code>, the arguments must explicitly be pointers (e.g. <code>vaargfn(2, &amp;b, &amp;&amp;3.0)</code>).</p>
<p>While explicit, this may be somewhat less user-friendly than implicit vararg functions:</p>
<h3 id="implicit-any-vararg-functions">Implicit <code>any</code> vararg functions</h3>
<p>The implicit <code>any</code> vararg function has instead a format like <code>fn void vaanyfn(int x, args...)</code>.
Calling this function will implicitly cause taking the pointer of the values (so for
example in the call <code>vaanyfn(2, b, 3.0)</code>, what is actually passed are <code>&amp;b</code> and <code>&amp;&amp;3.0</code>).</p>
<p>Because this passes values implicitly by reference, care must be taken <em>not</em> to mutate any
values passed in this manner. Doing so would very likely break user expectations.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../undefinedbehaviour/" class="btn btn-neutral float-right" title="Undefined behaviour">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../operators/" class="btn btn-neutral" title="Operator overloading"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../operators/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../undefinedbehaviour/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
