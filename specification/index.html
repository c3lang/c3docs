<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Specification - C3 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Specification";
    var mkdocs_page_input_path = "specification.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/ebnf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bnf.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> C3 Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">About C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Installing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../setup/">Setup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../firstproject/">Your first project</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../primer/">A quick primer on C3</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../allfeatures/">Feature list</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Documentation</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../changesfromc/">Changes from C</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compare/">Comparisons with other languages</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../types/">Types</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../define/">Define</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../arrays/">Arrays</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../vectors/">Vectors</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../statements/">Statements</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../expressions/">Expressions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../optionals/">Optionals and error handling</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compiletime/">Compile time evaluation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../contracts/">Contracts</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../generics/">Generics</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../macros/">Macros</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../reflection/">Reflection</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../operators/">Operator overloading</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../anyinterfaces/">Any and interfaces</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../undefinedbehaviour/">Undefined behaviour</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../conversion/">Conversions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../precedence/">Precedence</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../builtins/">Builtins</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../libraries/">Libraries</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../standard_library/">Standard Library</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ideas/">More ideas</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../naming/">Naming rules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../comments/">Comments & Docs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../attributes/">Attributes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../asm/">Inline asm</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cinterop/">C Interop</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../syntax/">Grammar</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../sample/">More code examples</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Specification</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#notation">Notation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#source-code-representation">Source code representation</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#lexical-translations">Lexical Translations</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#line-terminators">Line Terminators</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#input-elements-and-tokens">Input Elements and Tokens</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#white-space">White Space</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#letters-and-digits">Letters and digits</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#comments">Comments</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#doc-comments">Doc comments</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#identifiers">Identifiers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#keywords">Keywords</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#operators-and-punctuation">Operators and punctuation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#integer-literals">Integer literals</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#floating-point-literals">Floating point literals</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#characters">Characters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#backslash-escapes">Backslash escapes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#string-literals">String literals</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#compile-time-string-concatenation">Compile time string concatenation</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#raw-string-literals">Raw string literals</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#compile-time-concatenation">Compile time concatenation</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#source-code-pre-filtering">Source code pre-filtering</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#character-literals">Character literals</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#types">Types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#boolean-types">Boolean types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#integer-types">Integer types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#floating-point-types">Floating point types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#vector-types">Vector types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#vector-base-type">Vector base type</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#min-width">Min width</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#element-access">Element access</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#alignment">Alignment</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#vector-operations">Vector operations</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#array-types">Array types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#subarray-types">Subarray types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pointer-types">Pointer types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#pointee-type">Pointee type</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#iptr-and-uptr">iptr and uptr</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#the-wildcard-pointer-void">The wildcard pointer void*</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#pointer-arithmetic-on-void">Pointer arithmetic on void*</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#subscripting">Subscripting</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#deref">Deref</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_1"></a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#struct-types">Struct types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#alignment_1">Alignment</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#union-types">Union types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#alignment_2">Alignment</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#fault-types">Fault types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#alignment_3">Alignment</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#enum-types">Enum types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#function-types">Function types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#typeid-type">Typeid type</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#any-type">Any* type</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#fields">Fields</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#switching-over-any">Switching over any</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#anyfault-type">Anyfault type</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#declarations-and-scope">Declarations and scope</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#expressions">Expressions</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#assignment-expression">Assignment expression</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#type-assign">Type assign</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#combined-assign">Combined assign</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#implicit-conversion">Implicit conversion</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ternary-elvis-and-or-else-expressions">Ternary, elvis and or-else expressions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ternary-evaluation">Ternary evaluation</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#elvis-evaluation">Elvis evaluation</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#orelse-evaluation">Orelse evaluation</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#suffix-expression">Suffix expression</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#effect-of">Effect of "?"</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#type-of-the-expression">Type of the expression</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rethrow-expression">Rethrow expression</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#the-expression-to-rethrow">The expression to rethrow</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#type">Type</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#relational-expression">Relational expression</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#and-expression">And expression</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#type_1">Type</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#or-expression">Or expression</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#type_2">Type</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#casts">Casts</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pointer-casts">Pointer casts</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#integer-to-pointer-cast">Integer to pointer cast</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#pointer-to-integer-cast">Pointer to integer cast</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#subscript-operator">Subscript operator</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#operands">Operands</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compound-literals">Compound Literals</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#function-calls">Function calls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#varargs">Varargs</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#statements">Statements</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#asm-block-statement">Asm block statement</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#assert-statement">Assert statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#conditional-inclusion">Conditional inclusion</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#assert-message">Assert message</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#panic-function">Panic function</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#break-statement">Break statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#break-labels">Break labels</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unreachable-code">Unreachable code</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compile-time-echo-statement">Compile time echo statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#the-message">The message</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compile-time-assert-statement">Compile time assert statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#evaluated-expression">Evaluated expression</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#error-message">Error message</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compile-time-error-statement">Compile time error statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#error-message_1">Error message</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compile-time-if-statement">Compile time if statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cond-expression">Cond expression</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#scopes">Scopes</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#evaluation">Evaluation</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compile-time-switch-statement">Compile time switch statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#no-cond-expression-switch">No cond expression switch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#type-expressions">Type expressions</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ranged-cases">Ranged cases</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#fallthrough">Fallthrough</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#break-and-nextcase">Break and nextcase</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#evaluation-of-statements">Evaluation of statements</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#continue-statement">Continue statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#continue-labels">Continue labels</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unreachable-code_1">Unreachable code</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#declaration-statement">Declaration statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#thread-local-storage">Thread local storage</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#static-storage">Static storage</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#scopes_1">Scopes</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#multiple-declarations">Multiple declarations</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#no-init-expression">No init expression</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#opt-out-of-zero-initialization">Opt-out of zero initialization</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#self-referencing-initialization">Self referencing initialization</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defer-statement">Defer statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#defer-in-defer">Defer in defer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#static-and-tlocal-variables-in-defer">Static and tlocal variables in defer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#defer-and-return">Defer and return</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#defer-and-jump-statements">Defer and jump statements</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#defer-execution">Defer execution</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#defer-try">Defer try</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#defer-catch">Defer catch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#non-regular-returns-longjmp-panic-and-other-errors">Non-regular returns - longjmp, panic and other errors</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#expr-statement">Expr statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#no-discard">No discard</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#if-statement">If statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#scopes_2">Scopes</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#special-parsing-of-the-then-clause">Special parsing of the "then" clause</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#break">Break</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#if-try">If-try</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#if-catch">If-catch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#if-catch-implicit-unwrap">If-catch implicit unwrap</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#nextcase-statement">Nextcase statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#labels">Labels</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#no-expression-jumps">No expression jumps</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#jumps-to-default">Jumps to default</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#missing-case">Missing case</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#variable-expression">Variable expression</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unreachable-code_2">Unreachable code</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#switch-statement">Switch statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#regular-switch">Regular switch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#if-switch">If-switch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#any-switch">Any-switch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ranged-cases_1">Ranged cases</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#fallthrough_1">Fallthrough</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#exhaustive-switch">Exhaustive switch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#break_1">Break</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unreachable-code_3">Unreachable code</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#switching-over-typeid">Switching over typeid</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nextcase-without-expression">Nextcase without expression</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nextcase-with-expression">Nextcase with expression</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#do-statement">Do statement</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unreachable-code_4">Unreachable code</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#break_2">Break</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#continue">Continue</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#do-block">Do block</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#for-statement">For statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#init-expression">Init expression</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#incr-expression">Incr expression</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cond-expression_1">Cond expression</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unreachable-code_5">Unreachable code</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#break_3">Break</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#continue_1">Continue</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#equivalence-of-while-and-for">Equivalence of while and for</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#foreach-and-foreach_r-statements">Foreach and foreach_r statements</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#break_4">Break</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#continue_2">Continue</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#iteration-by-value-or-reference">Iteration by value or reference</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#foreach-variable">Foreach variable</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#foreach-index">Foreach index</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#foreach-support">Foreach support</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#return-statement">Return statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#jumps-in-return-statements">Jumps in return statements</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#return-from-expression-blocks">Return from expression blocks</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#empty-returns">Empty returns</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unreachable-code_6">Unreachable code</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#while-statement">While statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#unreachable-code_7">Unreachable code</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#break_5">Break</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#continue_3">Continue</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#var-statement">Var statement</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#inferring-type">Inferring type</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#scope">Scope</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#attributes">Attributes</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#user-defined-attributes">User defined attributes</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#empty-list-of-attributes">Empty list of attributes</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#parameter-arguments">Parameter arguments</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#expansion">Expansion</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nesting">Nesting</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#modules">Modules</a>
    </li>
    </ul>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Build system</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../buildintro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../project/">Project Structure</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../buildcommands/">Commands</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Development</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../contribute/">Contribute</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../changes/">Changes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../rejectedideas/">Rejected ideas</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">C3 Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Documentation &raquo;</li>
        
      
    
    <li>Specification</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="specification">Specification</h1>
<p><em>THIS SPECIFICATION IS UNDER DEVELOPMENT</em></p>
<h2 id="notation">Notation</h2>
<p>The syntax is specified using Extended Backus-Naur Form (EBNF):</p>
<pre><code>production  ::= PRODUCTION_NAME '::=' expression?
expression  ::= alternative (&quot;|&quot; alternative)* 
alternative ::= term term*
term        ::= PRODUCTION_NAME | TOKEN | set | group | option | repetition
set         ::= '[' (range | CHAR) (rang | CHAR)* ']'
range       ::= CHAR '-' CHAR 
group       ::= '(' expression ')'
option      ::= expression '?'
repetition  ::= expression '*'
</code></pre>
<p>Productions are expressions constructed from terms and the following operators, in increasing precedence:</p>
<pre><code>|   alternation
()  grouping
?  option (0 or 1 times)
*  repetition (0 to n times)
</code></pre>
<p>Uppercase production names are used to identify lexical tokens. Non-terminals are in lower case. Lexical tokens are
enclosed in single quotes ''.</p>
<p>The form <code>a..b</code> represents the set of characters from a through b as alternatives.</p>
<h2 id="source-code-representation">Source code representation</h2>
<p>A program consists of one or more <em>translation units</em> stored in files written in the Unicode character set,
stored as a sequence of bytes using the UTF-8 encoding. Except for comments and the contents of character and string
literals, all input elements are formed only from the ASCII subset (U+0000 to U+007F) of Unicode.</p>
<p>A raw byte stream is translated into a sequence of tokens which white space and non-doc comments are discarded. Doc
comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols
of the syntactic grammar.</p>
<h3 id="lexical-translations">Lexical Translations</h3>
<p>A raw byte stream is translated into a sequence of tokens which white space and non-doc comments are discarded. Doc
comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols
of the syntactic grammar.</p>
<p>The longest possible translation is used at each step, even if the result does not ultimately make a correct program
while another lexical translation would.</p>
<blockquote>
<p>Example: <code>a--b</code> is translated as <code>a</code>, <code>--</code>, <code>b</code>, which does not form a grammatically correct expression, even though the tokenization <code>a</code>, <code>-</code>, <code>-</code>, <code>b</code> could form a grammatically correct expression.</p>
</blockquote>
<h3 id="line-terminators">Line Terminators</h3>
<p>The C3 compiler divides the sequence of input bytes into lines by recognizing <em>line terminators</em></p>
<p>Lines are terminated by the ASCII LF character (U+000A), also known as "newline". A line termination specifies the
termination of the // form of a comment.</p>
<h3 id="input-elements-and-tokens">Input Elements and Tokens</h3>
<p>An input element may be:</p>
<ol>
<li>White space</li>
<li>Comment</li>
<li>Doc Comment</li>
<li>Token</li>
</ol>
<p>A token may be:</p>
<ol>
<li>Identifier</li>
<li>Keyword</li>
<li>Literal</li>
<li>Separator</li>
<li>Operator</li>
</ol>
<p>A Doc Comment consists of:</p>
<ol>
<li>A stream of descriptive text</li>
<li>A list of directive Tokens</li>
</ol>
<p>Those input elements that are not white space or comments are tokens. The tokens are the terminal symbols of the
syntactic grammar. Whitespace and comments can serve to separate tokens that might be tokenized in another manner. For
example the characters <code>+</code> and <code>=</code> may form the operator token <code>+=</code> only if there is no intervening white space or
comment.</p>
<h3 id="white-space">White Space</h3>
<p>White space is defined as the ASCII horizontal tab character (U+0009), form feed character (U+000A), vertical tab (
U+000B), carriage return (U+000D), space character (U+0020) and the line terminator character (U+000D).</p>
<pre><code>WHITESPACE      ::= [ \t\f\v\r\n]
</code></pre>
<h3 id="letters-and-digits">Letters and digits</h3>
<pre><code>UC_LETTER       ::= [A-Z]
LC_LETTER       ::= [a-z]
LETTER          ::= UC_LETTER | LC_LETTER
DIGIT           ::= [0-9]
HEX_DIGIT       ::= [0-9a-fA-F]
BINARY_DIGIT    ::= [01]
OCTAL_DIGIT     ::= [0-7]
LC_LETTER_US    ::= LC_LETTER | &quot;_&quot;
UC_LETTER_US    ::= UC_LETTER | &quot;_&quot;
ALPHANUM        ::= LETTER | DIGIT
ALPHANUM_US     ::= ALPHANUM | &quot;_&quot;
UC_ALPHANUM_US  ::= UC_LETTER_US | DIGIT
LC_ALPHANUM_US  ::= LC_LETTER_US | DIGIT
</code></pre>
<h3 id="comments">Comments</h3>
<p>There are three types of regular comments:</p>
<ol>
<li><code>// text</code> a line comment. The text between <code>//</code> and line end is ignored.</li>
<li><code>/* text */</code> block comments. The text between <code>/*</code> and <code>*/</code> is ignored. It has nesting behaviour, so for every <code>/*</code>
   discovered between the first <code>/*</code> and the last <code>*/</code> a corresponding <code>*/</code> must be found.</li>
</ol>
<h3 id="doc-comments">Doc comments</h3>
<ol>
<li><code>/** text **/</code> doc block comment. The text between <code>/**</code> and <code>**/</code> is optionally parsed using the doc comment
   syntactic grammar. A compiler may choose to read <code>/** text **/</code> as a regular comment.</li>
</ol>
<h3 id="identifiers">Identifiers</h3>
<p>Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and
digits.
The first character in an identifier must be a letter or underscore.</p>
<p>C3 has three types of identifiers: const identifiers - containing only underscore and upper-case letters,
type identifiers - starting with an upper case letter followed by at least one underscore letter and regular
identifiers, starting with a lower case letter.</p>
<pre><code>IDENTIFIER      ::=  &quot;_&quot;* LC_LETTER ALPHANUM_US*
CONST_IDENT     ::=  &quot;_&quot;* UC_LETTER UC_ALPHANUM_US*
TYPE_IDENT      ::=  &quot;_&quot;* UC_LETTER &quot;_&quot;* LC_LETTER ALPHANUM_US*
CT_IDENT        ::=  &quot;$&quot; IDENTIFIER
CT_CONST_IDENT  ::=  &quot;$&quot; CONST_IDENT
CT_TYPE_IDENT   ::=  &quot;$&quot; TYPE_IDENT
AT_TYPE_IDENT   ::=  &quot;@&quot; TYPE_IDENT
PATH_SEGMENT    ::= &quot;_&quot;* LC_LETTER LC_ALPHANUM_US*
</code></pre>
<h3 id="keywords">Keywords</h3>
<p>The following keywords are reserved and may not be used as identifiers:</p>
<pre><code>asm         any         anyfault
assert      attribute   break
case        cast        catch
const       continue    default
defer       def         do
else        enum        extern
errtype     false       fn
generic     if          import
inline      macro
module      nextcase    null
public      return      struct
switch      true        try
typeid      var         void        
while

bool        quad        double      
float       long        ulong
int         uint        byte
short       ushort      char
isz         usz         float16
float128

$and        $assert     $case       
$default    $echo       $else       
$error      $endfor     $endforeach 
$endif      $endswitch  $for        
$foreach    $if         $switch     
$typef      $vaarg      $vaconst
$vacount    $varef      $vatype             

</code></pre>
<h3 id="operators-and-punctuation">Operators and punctuation</h3>
<p>The following character sequences represent operators and punctuation.</p>
<pre><code>&amp;       @       ~       |       ^       :
,       /       $       .       ;       )
&gt;       &lt;       #       {       }       -
(       )       *       [       ]       %
&gt;=      &lt;=      +       +=      -=      !
?       ?:      &amp;&amp;      ??      &amp;=      |=
^=      /=      ..      ==      ({      })
[&lt;      &gt;]      (&lt;      &gt;)      ++      --      
%=      !=      ||      ::      &lt;&lt;      &gt;&gt;      
!!      ...     &lt;&lt;=     &gt;&gt;=
</code></pre>
<h3 id="integer-literals">Integer literals</h3>
<p>An integer literal is a sequence of digits representing an integer constant.
An optional prefix sets a non-decimal base: 0b or 0B for binary,
0o, or 0O for octal, and 0x or 0X for hexadecimal.
A single 0 is considered a decimal zero.
In hexadecimal literals, letters a through f and A through F represent values 10 through 15.</p>
<p>For readability, an underscore character _ may appear after a base prefix
or between successive digits; such underscores do not change the literal's value.</p>
<pre><code>INTEGER         ::= DECIMAL_LIT | BINARY_LIT | OCTAL_LIT | HEX_LIT
DECIMAL_LIT     ::= '0' | [1-9] ('_'* DECIMAL_DIGITS)?
BINARY_LIT      ::= '0' [bB] '_'* BINARY_DIGITS
OCTAL_LIT       ::= '0' [oO] '_'* OCTAL_DIGITS
HEX_LIT         ::= '0' [xX] '_'* HEX_DIGITS

BINARY_DIGIT    ::= [01]
HEX_DIGIT       ::= [0-9a-fA-F]

DECIMAL_DIGITS  ::= DIGIT ('_'* DIGIT)*
BINARY_DIGITS   ::= BINARY_DIGIT ('_'* BINARY_DIGIT)*
OCTAL_DIGITS    ::= OCTAL_DIGIT ('_'* OCTAL_DIGIT)*
HEX_DIGITS      ::= HEX_DIGIT ('_'* HEX_DIGIT)*
</code></pre>
<pre><code>42
4_2
0_600
0o600
0O600           // second character is capital letter 'O'
0xBadFace
0xBad_Face
0x_67_7a_2f_cc_40_c6
170141183460469231731687303715884105727
170_141183_460469_231731_687303_715884_105727

0600            // Invalid, non zero decimal number may not start with 0 
_42             // an identifier, not an integer literal
42_             // invalid: _ must separate successive digits
0_xBadFace      // invalid: _ must separate successive digits
</code></pre>
<h3 id="floating-point-literals">Floating point literals</h3>
<p>A floating-point literal is a decimal or hexadecimal representation of a floating-point constant.</p>
<p>A decimal floating-point literal consists of an integer part (decimal digits), a decimal point,
a fractional part (decimal digits), and an exponent part (e or E followed by an optional
sign and decimal digits). One of the integer part or the fractional part may be elided;
one of the decimal point or the exponent part may be elided. An exponent value exp scales
the mantissa (integer and fractional part) by powers of 10.</p>
<p>A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part
(hexadecimal digits), a radix point, a fractional part (hexadecimal digits),
and an exponent part (p or P followed by an optional sign and decimal digits).
One of the integer part or the fractional part may be elided; the radix point
may be elided as well, but the exponent part is required.
An exponent value exp scales the mantissa (integer and fractional part) by powers of 2.</p>
<p>For readability, an underscore character _ may appear after a base prefix or between successive digits;
such underscores do not change the literal value.</p>
<pre><code>FLOAT_LIT       ::= DEC_FLOAT_LIT | HEX_FLOAT_LIT
DEC_FLOAT_LIT   ::= DECIMAL_DIGITS '.' DECIMAL_DIGITS? DEC_EXPONENT? 
                    | DECIMAL_DIGITS DEC_EXPONENT
                    | '.' DECIMAL_DIGITS DEC_EXPONENT?
DEC_EXPONENT    ::= [eE] [+-]? DECIMAL_DIGITS
HEX_FLOAT_LIT   ::= '0' [xX] HEX_MANTISSA HEX_EXPONENT
HEX_MANTISSA    ::= HEX_DIGITS '.' HEX_DIGITS?
                    | HEX_DIGITS
                    | '.' HEX_DIGITS 
HEX_EXPONENT    ::= [pP] [+-] DECIMAL_DIGITS                    
</code></pre>
<h3 id="characters">Characters</h3>
<p>Characters are the fundamental components of strings and character literals.</p>
<pre><code>CHAR_ELEMENT    ::= [\x20-\x26] | [\x28-\x5B] | [\x5D-\x7F]
CHAR_LIT_BYTE   ::= CHAR_ELEMENT | \x5C CHAR_ESCAPE
CHAR_ESCAPE     ::= [abefnrtv\'\&quot;\\] 
                    | 'x' HEX_DIGIT HEX_DIGIT
UNICODE_CHAR    ::= unicode_char                    
                    | 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
                    | 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT 
                          HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
</code></pre>
<h3 id="backslash-escapes">Backslash escapes</h3>
<p>The following backslash escapes are available for characters and string literals:</p>
<pre><code class="language-text">\0      0x00 zero value
\a      0x07 alert/bell
\b      0x08 backspace
\e      0x1B escape
\f      0x0C form feed
\n      0x0A newline
\r      0x0D carriage return
\t      0x09 horizontal tab
\v      0x0B vertical tab
\\      0x5C backslash
\'      0x27 single quote '
\&quot;      0x22 double quote &quot;
\x      Escapes a single byte hex value
\u      Escapes a two byte unicode hex value 
\U      Escapes a four byte unicode hex value
</code></pre>
<h3 id="string-literals">String literals</h3>
<p>A string literal represents a string constant obtained from concatenating a sequence of characters.
String literals are character sequences between double quotes, as in "bar". Within the quotes,
any character may appear except newline and unescaped double quote. The text between the
quotes forms the value of the literal, with backslash escapes interpreted as they are in
rune literals, with the same restrictions. The two-digit hexadecimal (\xnn) escapes represent
individual bytes of the resulting string; all other escapes represent the (possibly multibyte)
UTF-8 encoding of individual characters. Thus inside a string literal <code>\xFF</code> represent a single
byte of value <code>0xFF</code> = 255, while <code>ÿ</code>, <code>\u00FF</code>, <code>\U000000FF</code> and <code>\xc3\xbf</code> represent the two bytes
<code>0xc3 0xbf</code> of the UTF-8 encoding of character <code>U+00FF</code>.</p>
<pre><code>STRING_LIT      ::= \x22 (CHAR_LIT_BYTE | UNICODE_CHAR)* \x22
</code></pre>
<h4 id="compile-time-string-concatenation">Compile time string concatenation</h4>
<p>Strings will concatenate if declared in sequence.</p>
<p>Example:</p>
<pre><code class="language-c">String s = &quot;abc&quot; &quot;def&quot; &quot;ghi&quot;;
// This is equivalent to:
String s = &quot;abcdefghi&quot;;
</code></pre>
<h3 id="raw-string-literals">Raw string literals</h3>
<p>Raw string literals are enclosed between `` and consist of the raw UTF8 in the source
code between the "`". A sequence of two "`" will be interpreted as a single escaped "`" that does
not terminate the literal.</p>
<h4 id="compile-time-concatenation">Compile time concatenation</h4>
<p>Raw strings will concatenate with other regular strings and raw strings (
see <a href="#compile-time-string-concatenation">string literal compile time concatenation</a>).</p>
<h4 id="source-code-pre-filtering">Source code pre-filtering</h4>
<p>The source code will pre-filter <code>\r</code> (<code>0x0D</code>) from the source code. This means that it is also implicitly
filtered out of raw strings.</p>
<h3 id="character-literals">Character literals</h3>
<p>A character literal is enclosed in <code>'</code> and may either consist of 1, 2, 4, 8, 16 bytes.</p>
<pre><code>CHARACTER_LIT   ::= &quot;'&quot; (CHAR_LIT_BYTE+) | UNICODE_CHAR &quot;'&quot;
</code></pre>
<h2 id="types">Types</h2>
<p>Types consist of built-in types and user-defined types (enums, structs, unions, bitstructs, fault and distinct).</p>
<h3 id="boolean-types">Boolean types</h3>
<p><code>bool</code> may have the two values <code>true</code> and <code>false</code>. It holds a single bit of information but is
stored in a <code>char</code> type.</p>
<h3 id="integer-types">Integer types</h3>
<p>The built-in integer types:</p>
<pre><code class="language-text">char      unsigned 8-bit
ichar     signed 8-bit
ushort    unsigned 16-bit
short     signed 16-bit
uint      unsigned 32-bit
int       signed 32-bit
ulong     unsigned 64-bit
long      signed 64-bit
uint128   unsigned 128-bit
int128    singed 128-bit
</code></pre>
<p>In addition, the following type aliases exist:</p>
<pre><code class="language-text">uptr      unsigned pointer size
iptr      signed pointer size
usz       unsigned pointer offset / object size
isz       signed pointer offset  / object size
</code></pre>
<h3 id="floating-point-types">Floating point types</h3>
<p>Built-in floating point types:</p>
<pre><code>float16   IEEE 16-bit*
bfloat16  Brainfloat*
float     IEEE 32-bit
double    IEEE 64-bit
float128  IEEE 128-bit*
</code></pre>
<p>(* optionally supported)</p>
<h3 id="vector-types">Vector types</h3>
<p>A vector lowers to the platform's vector types where available. A vector has a base type and a width.</p>
<pre><code>vector_type        ::= type &quot;[&lt;&quot; length &quot;&gt;]&quot;
</code></pre>
<h4 id="vector-base-type">Vector base type</h4>
<p>The base type of a vector must be boolean, an integer or a floating point type.</p>
<h4 id="min-width">Min width</h4>
<p>The vector width must be at least 1.</p>
<h4 id="element-access">Element access</h4>
<p>Vector elements are accessed using <code>[]</code>. It is possible to take the address of a single element.</p>
<h4 id="alignment">Alignment</h4>
<p>Alignment of vectors are platform dependent, but is at least the alignment of its element type.</p>
<h4 id="vector-operations">Vector operations</h4>
<p>Vectors support the same arithmetics as its underlying type, and will perform the operation
element-wise.</p>
<p>Example:</p>
<pre><code class="language-c">int[&lt;2&gt;] a = { 1, 3 };
int[&lt;2&gt;] b = { 2, 7 };

int[&lt;2&gt;] c = a * b;
// Equivalent to
int[&lt;2&gt;] c = { a[0] * b[0], a[1] * b[1] };
</code></pre>
<h3 id="array-types">Array types</h3>
<p>An array has the alignment of its elements. An array must have at least one element.</p>
<h3 id="subarray-types">Subarray types</h3>
<p>The subarray consist of a pointer, followed by an usz length, having the alignment of pointers.</p>
<h3 id="pointer-types">Pointer types</h3>
<p>A pointer is the address to memory.</p>
<pre><code class="language-text">pointer_type       ::= type &quot;*&quot;
</code></pre>
<h4 id="pointee-type">Pointee type</h4>
<p>The type of the memory pointed to is the <strong>pointee type</strong>. It may be any runtime type.</p>
<h4 id="iptr-and-uptr">iptr and uptr</h4>
<p>A pointer may be losslessly cast to an <code>iptr</code> or <code>uptr</code>. An <code>iptr</code> or <code>uptr</code> may be cast to a pointer of any type.</p>
<h4 id="the-wildcard-pointer-void">The wildcard pointer void*</h4>
<p>The <code>void*</code> may implicitly cast into any other pointer type. The <code>void*</code>
[implicitly casts into any other pointer.</p>
<p>A void* pointer may never be dereferenced.</p>
<h4 id="pointer-arithmetic-on-void">Pointer arithmetic on void*</h4>
<p>Performing pointer arithmetics on void* will assume that the element size is 1. This includes
pointer arithmetics using subscripting.</p>
<h4 id="subscripting">Subscripting</h4>
<p>Subscripting a pointer is equal to performing pointer arithmetics using the index, followed by a deref.
Subscripts on pointers may be negative and will never do bounds checks.</p>
<h4 id="deref">Deref</h4>
<p>Dereferencing a pointer will return the value in the memory location interpreted as the <strong>pointee type</strong>.</p>
<h4 id="_1"></h4>
<h3 id="struct-types">Struct types</h3>
<p>A struct may not have zero members.</p>
<h4 id="alignment_1">Alignment</h4>
<p>A non-packed struct has the alignment of the member that has the highest alignment. A packed struct
has alignment 1. See <a href="#align-attribute">align attribute</a> for details on changing the alignment.</p>
<h3 id="union-types">Union types</h3>
<p>A union may not have zero members.</p>
<h4 id="alignment_2">Alignment</h4>
<p>A union has the alignment of the member that has the highest alignment. See <a href="#align-attribute">align attribute</a> for
details on changing the alignment.</p>
<h3 id="fault-types">Fault types</h3>
<p>A fault is an extensible enum which can be used to create an <a href="#optional-types">optional</a>.</p>
<h4 id="alignment_3">Alignment</h4>
<p>A fault type has the same alignment as a pointer. See <a href="#align-attribute">align attribute</a> for details on changing the
alignment.</p>
<h3 id="enum-types">Enum types</h3>
<h3 id="function-types">Function types</h3>
<h3 id="typeid-type">Typeid type</h3>
<p>The typeid is a pointer sized value which uniquely identifies a type.</p>
<h3 id="any-type">Any* type</h3>
<p>The <code>any*</code> is a fat pointer (2 pointers wide) holding a pointer to a value and its corresponding <a href="#typeid-type">typeid</a>.
It cannot be dereferenced.</p>
<h4 id="fields">Fields</h4>
<p><code>.ptr</code> returns a <code>void*</code> pointer to the underlying value <code>.type</code> returns the <a href="#typeid-type">typeid</a>
of the underlying value.</p>
<h4 id="switching-over-any">Switching over <code>any</code></h4>
<p>Switching over an <code>any</code> value creates an <a href="any-switch">any switch</a>.</p>
<h3 id="anyfault-type">Anyfault type</h3>
<h2 id="declarations-and-scope">Declarations and scope</h2>
<h2 id="expressions">Expressions</h2>
<h3 id="assignment-expression">Assignment expression</h3>
<pre><code>assignment_expr    ::= ct_type_assign | unary_expr assignment_op expr
ct_type_assign     ::= ct_type_ident &quot;=&quot; type
assignment_op      ::= &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; | &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&amp;=&quot; | &quot;^=&quot; | &quot;|=&quot;
</code></pre>
<h4 id="type-assign">Type assign</h4>
<p>This assigns a new type to a compile time type variable. The value of the expression is the type assigned.</p>
<h4 id="combined-assign">Combined assign</h4>
<p>All assignment operations except for "=" are combined assign operation. They first perform the operation indicated
by the leftmost character(s) in the operator (e.g <code>+</code> for <code>+=</code>, <code>&lt;&lt;</code> for <code>&lt;&lt;=</code> etc) with the lhs and the rhs.
The result is then assigned to the left hand side. The result of the operation is the new value of the left
hand side.</p>
<h4 id="implicit-conversion">Implicit conversion</h4>
<p>If the left hand side is a pointer and the operation is "+=" or "-=" an attempt to implicitly convert to
isz/usz will be tried.</p>
<p>For all other types and operations, <strong>an implicit conversion</strong> of rhs to the type of lhs will be tried.</p>
<h3 id="ternary-elvis-and-or-else-expressions">Ternary, elvis and or-else expressions</h3>
<pre><code>ternary_group_expr ::= suffix_group_expr | ternary_expr | elvis_expr | orelse_expr
ternary_expr       ::= or_expr &quot;?&quot; expr &quot;:&quot; ternary_group_expr
elvis_expr         ::= suffix_expr &quot;?:&quot; ternary_group_expr
orelse_expr        ::= suffix_expr &quot;??&quot; ternary_group_expr
</code></pre>
<h4 id="ternary-evaluation">Ternary evaluation</h4>
<p>The most left-hand expression is evaluated to a boolean. If it is true, the value of the middle
expression is returned, otherwise the last expression is returned.</p>
<p>Only the most left-hand expression and the returned expressions are evaluated.</p>
<p>The middle and last expression are implicitly converted to their <strong>unified type</strong>.</p>
<p>The resulting type is the <strong>unified type</strong>.</p>
<h4 id="elvis-evaluation">Elvis evaluation</h4>
<p>Lhs and rhs are implicitly converted to their <strong>unified type</strong>.</p>
<p>The lhs is evaluated, it is then converted to a boolean, if the result it true, return the lhs value
before its boolean conversion. Otherwise return the right hand side.</p>
<p>The right hand side is only evaluated if the lhs evaluates to false.</p>
<p>The resulting type is the <strong>unified type</strong>.</p>
<h4 id="orelse-evaluation">Orelse evaluation</h4>
<p>The lhs must be optional. The non-optional type for lhs and rhs are calculated.
The <strong>unified type</strong> of the result is calculated. Lhs are converted to the unified type
preserving their optionality.</p>
<p>At runtime, lhs is evaluated. If it evaluates to an optional, rhs is returned instead.</p>
<p>Rhs is only evaluated if lhs evaluates to an optional.</p>
<p>The resulting type of the orelse is the post conversion type of the rhs.</p>
<h3 id="suffix-expression">Suffix expression</h3>
<p>Suffix expressions convert a fault to an optional.</p>
<pre><code>suffix_group_exp   ::= or_group_expr | suffix_expr
suffix_expr        ::= or_group_expr &quot;?&quot; &quot;!&quot;?
</code></pre>
<h4 id="effect-of">Effect of "?"</h4>
<p>The "?" will convert the expression into an optional. The left hand side must be a fault type.
If an optional "!" follows, this optional is immediately returned, as if by a <code>return &lt;expr&gt;?</code> statement.</p>
<h4 id="type-of-the-expression">Type of the expression</h4>
<p>The type is a <strong>wildcard optional</strong>. If "!" is added, it is a <strong>wildcard</strong> type.</p>
<h3 id="rethrow-expression">Rethrow expression</h3>
<p>If the expression is optional, implicitly return with the optional value.</p>
<pre><code>rethrow_expr       ::= expr &quot;!&quot;
</code></pre>
<h4 id="the-expression-to-rethrow">The expression to rethrow</h4>
<p>The expression must have an optional type, otherwise this is a compile time error.</p>
<h4 id="type">Type</h4>
<p>The type of "rethrow" is the inner expr type without optional.</p>
<h3 id="relational-expression">Relational expression</h3>
<pre><code>rel_group_expr     ::= add_group_expr | relational_expr
relational_expr    ::= rel_group_expr relational_op add_group_expr
relational_op      ::= &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot; 
</code></pre>
<p>TODO</p>
<h3 id="and-expression">And expression</h3>
<p>This binary expression evaluates the lhs, and if the result is <code>true</code> evaluates the rhs. The
result is true if both lhs and rhs are true.</p>
<pre><code>and_group_expr     ::= rel_group_expr | and_expr
and_expr           ::= and_group_expr &quot;&amp;&amp;&quot; rel_group_expr
</code></pre>
<h4 id="type_1">Type</h4>
<p>The type of the and-expression is <code>bool</code>.</p>
<h3 id="or-expression">Or expression</h3>
<p>This binary expression evaluates the lhs, and if the result is <code>false</code> evaluates the rhs. The
result is true if lhs or rhs is true.</p>
<pre><code>or_group_expr      ::= and_group_expr | or_expr
or_expr            ::= or_group_expr &quot;||&quot; and_group_expr
</code></pre>
<h4 id="type_2">Type</h4>
<p>The type of the or-expression is <code>bool</code>.</p>
<h3 id="casts">Casts</h3>
<h3 id="pointer-casts">Pointer casts</h3>
<h4 id="integer-to-pointer-cast">Integer to pointer cast</h4>
<p>Any integer of pointer size or larger may be explicitly cast to a pointer. An integer to pointer cast is considered
non-constant, except in the special case where the integer == 0. In that case, the result is constant <code>null</code>.</p>
<p>Example:</p>
<pre><code>byte a = 1;
int* b = (int*)a; // Invalid, pointer type is &gt; 8 bits.
int* c = (int*)1; // Valid, but runtime value.
int* d = (int*)0; // Valid and constant value.
</code></pre>
<h4 id="pointer-to-integer-cast">Pointer to integer cast</h4>
<p>A pointer may be cast to any integer, truncating the pointer value if the size of the pointer is larger than the pointer
size. A pointer to integer cast is considered non-constant, except in the special case of a null pointer, where it is
equal to the integer value 0.</p>
<p>Example:</p>
<pre><code>fn void test() { ... }
def VoidFunc = fn void test();

VoidFunc a = &amp;test;
int b = (int)null;
int c = (int)a; // Invalid, not constant
int d = (int)((int*)1); // Invalid, not constant
</code></pre>
<h3 id="subscript-operator">Subscript operator</h3>
<p>The subscript operator may take as its left side a pointer, array, subarray or vararray. The index may be of any integer
type. TODO
<em>NOTE</em> The subscript operator is not symmetrical as in C. For example in C3 <code>array[n] = 33</code> is allowed, but
not <code>n[array] = 33</code>. This is a change from C.</p>
<h3 id="operands">Operands</h3>
<h3 id="compound-literals">Compound Literals</h3>
<p>Compound literals have the format</p>
<pre><code>compound_literal   ::= TYPE_IDENTIFIER '(' initializer_list ')'
initializer_list   ::= '{' (initializer_param (',' initializer_param)* ','?)? '}'
initializer_param  ::= expression | designator '=' expression
designator         ::= array_designator | range_designator | field_designator
array_designator   ::= '[' expression ']'
range_designator   ::= '[' range_expression ']'
field_designator   ::= IDENTIFIER
range_expression   ::= (range_index)? '..' (range_index)?
range_index        ::= expression | '^' expression
</code></pre>
<p>Taking the address of a compound literal will yield a pointer to stack allocated temporary.</p>
<h3 id="function-calls">Function calls</h3>
<h4 id="varargs">Varargs</h4>
<p>For varargs, a <code>bool</code> or <em>any integer</em> smaller than what the C ABI specifies for the c <code>int</code> type is cast to <code>int</code>. Any
float smaller than a double is cast to <code>double</code>. Compile time floats will be cast to double. Compile time integers will
be cast to c <code>int</code> type.</p>
<h2 id="statements">Statements</h2>
<pre><code>stmt               ::= compound_stmt | non_compound_stmt
non_compound_stmt  ::= assert_stmt | if_stmt | while_stmt | do_stmt | foreach_stmt | foreach_r_stmt 
                       | for_stmt | return_stmt | break_stmt | continue_stmt | var_stmt 
                       | declaration_stmt | defer_stmt | nextcase_stmt | asm_block_stmt
                       | ct_echo_stmt | ct_error_stmt | ct_assert_stmt | ct_if_stmt | ct_switch_stmt 
                       | ct_for_stmt | ct_foreach_stmt | expr_stmt 
</code></pre>
<h3 id="asm-block-statement">Asm block statement</h3>
<p>An asm block is either a string expression or a brace enclosed list of asm statements.</p>
<pre><code>asm_block_stmt      ::= &quot;asm&quot; (&quot;(&quot; constant_expr &quot;)&quot; | &quot;{&quot; asm_stmt* &quot;}&quot;)
asm_stmt            ::= asm_instr asm_exprs? &quot;;&quot;
asm_instr           ::= (&quot;int&quot; | IDENTIFIER) (&quot;.&quot; IDENTIFIER)
asm_expr            ::= CT_IDENT | CT_CONST_IDENT | &quot;&amp;&quot;? IDENTIFIER | CONST_IDENT | FLOAT_LITERAL
                        | INTEGER | &quot;(&quot; expr &quot;)&quot; | &quot;[&quot; asm_addr &quot;]&quot;
asm_addr            ::= asm_expr (additive_op asm_expr asm_addr_trail?)?
asm_addr_trail      ::= &quot;*&quot; INTEGER (additive_op INTEGER)? | (shift_op | additive_op) INTEGER                         
</code></pre>
<p>TODO</p>
<h3 id="assert-statement">Assert statement</h3>
<p>The assert statement will evaluate the expression and call the panic function if it evaluates
to false.</p>
<pre><code>assert_stmt        ::= &quot;assert&quot; &quot;(&quot; expr (&quot;,&quot; assert_message)? &quot;)&quot; &quot;;&quot;
assert_message     ::= constant_expr (&quot;,&quot; expr)*
</code></pre>
<h4 id="conditional-inclusion">Conditional inclusion</h4>
<p><code>assert</code> statements are only included in "safe" builds. They may turn into <strong>assume directives</strong> for
the compiler on "fast" builds.</p>
<h4 id="assert-message">Assert message</h4>
<p>The assert message is optional. It can be followed by an arbitrary number of expressions, in which case
the message is understood to be a format string, and the following arguments are passed as values to the
format function.</p>
<p>The assert message must be a compile time constant. There are no restriction on the format argument expressions.</p>
<h4 id="panic-function">Panic function</h4>
<p>If the assert message has no format arguments or no assert message is included,
then the regular panic function is called. If it has format arguments then <code>panicf</code> is called instead.</p>
<p>In the case the <code>panicf</code> function does not exist (for example, compiling without the standard library),
then the format and the format arguments will be ignored and the <code>assert</code> will be treated
as if no assert message was available.</p>
<h3 id="break-statement">Break statement</h3>
<p>A break statement exits a <code>while</code>, <code>for</code>, <code>do</code>, <code>foreach</code> or <code>switch</code> scope. A labelled break
may also exit a labelled <code>if</code>.</p>
<pre><code>break_stmt         ::= &quot;break&quot; label? &quot;;&quot;
</code></pre>
<h4 id="break-labels">Break labels</h4>
<p>If a break has a label, then it will instead exit an outer scope with the label.</p>
<h4 id="unreachable-code">Unreachable code</h4>
<p>Any statement following break in the same scope is considered unreachable.</p>
<h3 id="compile-time-echo-statement">Compile time echo statement</h3>
<p>During parsing, the compiler will output the text in the statement when it is semantically checked.
The statement will be turned into a NOP statement after checking.</p>
<pre><code>ct_echo_stmt       ::= &quot;$echo&quot; constant_expr &quot;;&quot;
</code></pre>
<h4 id="the-message">The message</h4>
<p>The message must be a compile time constant string.</p>
<h3 id="compile-time-assert-statement">Compile time assert statement</h3>
<p>During parsing, the compiler will check the compile time expression
and create a compile time error with the optional message. After
evaluation, the <code>$assert</code> becomes a <strong>NOP</strong> statement.</p>
<pre><code>ct_assert_stmt     ::= &quot;$assert&quot; constant_expr (&quot;:&quot; constant_expr) &quot;;&quot;
</code></pre>
<h4 id="evaluated-expression">Evaluated expression</h4>
<p>The checked expression must evaluate to a boolean compile time constant.</p>
<h4 id="error-message">Error message</h4>
<p>The second parameter, which is optional, must evaluate to a constant string.</p>
<h3 id="compile-time-error-statement">Compile time error statement</h3>
<p>During parsing, when semantically checked this statement will output
a compile time error with the message given.</p>
<pre><code>ct_error_stmt      ::= &quot;$error&quot; constant_expr &quot;;&quot;
</code></pre>
<h4 id="error-message_1">Error message</h4>
<p>The parameter must evaluate to a constant string.</p>
<h3 id="compile-time-if-statement">Compile time if statement</h3>
<p>If the cond expression is true, the then-branch is processed by the compiler. If it
evaluates to false, the else-branch is processed if it exists.</p>
<pre><code>ct_if_stmt         ::= &quot;$if&quot; constant_expr &quot;:&quot; stmt* (&quot;$else&quot; stmt*)? &quot;$endif&quot;
</code></pre>
<h4 id="cond-expression">Cond expression</h4>
<p>The cond expression must be possible to evaluate to true or false at compile time.</p>
<h4 id="scopes">Scopes</h4>
<p>The "then" and "else" branches will add a compile time scope that is exited when reaching <code>$endif</code>.
It adds no runtime scope.</p>
<h4 id="evaluation">Evaluation</h4>
<p>Statements in the branch not picked will not be semantically checked.</p>
<h3 id="compile-time-switch-statement">Compile time switch statement</h3>
<pre><code>ct_switch_stmt     ::= &quot;$switch&quot; (&quot;(&quot; ct_expr_or_type &quot;)&quot;)? ct_case_stmt+ &quot;$endswitch&quot;
ct_case_stmt       ::= (&quot;$default&quot; | &quot;$case&quot; ct_expr_or_type) &quot;:&quot; stmt* 
</code></pre>
<h4 id="no-cond-expression-switch">No cond expression switch</h4>
<p>If the cond expression is missing, evaluation will go through each case until one case expression
evaluates to true.</p>
<h4 id="type-expressions">Type expressions</h4>
<p>If a cond expression is a type, then all case statement expressions must be types as well.</p>
<h4 id="ranged-cases">Ranged cases</h4>
<p>Compile time switch does not support ranged cases.</p>
<h4 id="fallthrough">Fallthrough</h4>
<p>If a case clause has no statements, then when executing the case, rather than exiting the switch,
the next case clause immediately following it will be used. If that one should also be missing statements,
the procedure will be repeated until a case clause with statements is encountered,
or the end of the switch is reached.</p>
<h4 id="break-and-nextcase">Break and nextcase</h4>
<p>Compile time switches do not support <code>break</code> nor <code>nextcase</code>.</p>
<h4 id="evaluation-of-statements">Evaluation of statements</h4>
<p>Only the case which is first matched has its statements processed by the compiler. All other statements
are ignored and will not be semantically checked.</p>
<h3 id="continue-statement">Continue statement</h3>
<p>A continue statement jumps to the cond expression of a <code>while</code>, <code>for</code>, <code>do</code> or <code>foreach</code></p>
<pre><code>continue_stmt      ::= &quot;continue&quot; label? &quot;;&quot;
</code></pre>
<h4 id="continue-labels">Continue labels</h4>
<p>If a <code>continue</code> has a label, then it will jump to the cond of the while/for/do in the outer scope
with the corresponding label.</p>
<h4 id="unreachable-code_1">Unreachable code</h4>
<p>Any statement following <code>continue</code> in the same scope is considered unreachable.</p>
<h3 id="declaration-statement">Declaration statement</h3>
<p>A declaration statement adds a new runtime or compile time variable to the current scope. It is available after the
declaration statement.</p>
<pre><code>declaration_stmt   ::= const_declaration | local_decl_storage? optional_type decls_after_type &quot;;&quot;
local_decl_storage ::= &quot;tlocal&quot; | &quot;static&quot;
decls_after_type   ::= local_decl_after_type (&quot;,&quot; local_decl_after_type)*
decl_after_type    ::= CT_IDENT (&quot;=&quot; constant_expr)? | IDENTIFIER opt_attributes (&quot;=&quot; expr)?
</code></pre>
<h4 id="thread-local-storage">Thread local storage</h4>
<p>Using <code>tlocal</code> allocates the runtime variable as a <strong>thread local</strong> variable. In effect this is the same as declaring
the variable as a global <code>tlocal</code> variable, but the visibility is limited to the function. <code>tlocal</code> may not be
combined with <code>static</code>.</p>
<p>The initializer for a <code>tlocal</code> variable must be a valid global init expression.</p>
<h4 id="static-storage">Static storage</h4>
<p>Using <code>static</code> allocates the runtime variable as a function <strong>global</strong> variable. In effect this is the same as declaring
a global, but visibility is limited to the function. <code>static</code> may not be combined with <code>tlocal</code>.</p>
<p>The initializer for a <code>static</code> variable must be a valid global init expression.</p>
<h4 id="scopes_1">Scopes</h4>
<p>Runtime variables are added to the runtime scope, compile time variables to the compile time scope. See <strong>var statements
</strong>.</p>
<h4 id="multiple-declarations">Multiple declarations</h4>
<p>If more than one variable is declared, no init expressions are allowed for any of the variables.</p>
<h4 id="no-init-expression">No init expression</h4>
<p>If no init expression is provided, the variable is <strong>zero initialized</strong>.</p>
<h4 id="opt-out-of-zero-initialization">Opt-out of zero initialization</h4>
<p>Using the @noinit attribute opts out of <strong>zero initialization</strong>.</p>
<h4 id="self-referencing-initialization">Self referencing initialization</h4>
<p>An init expression may refer to the <strong>address</strong> of the same variable that is declared, but not the <strong>value</strong> of the
variable.</p>
<p>Example:</p>
<pre><code class="language-c">void* a = &amp;a;  // Valid
int a = a + 1; // Invalid
</code></pre>
<h3 id="defer-statement">Defer statement</h3>
<p>The defer statements are executed at (runtime) scope exit, whether through <code>return</code>, <code>break</code>, <code>continue</code> or rethrow.</p>
<pre><code>defer_stmt         ::= &quot;defer&quot; (&quot;try&quot; | &quot;catch&quot;)? stmt
</code></pre>
<h4 id="defer-in-defer">Defer in defer</h4>
<p>The defer body (statement) may not be a defer statement. However, if the body is a compound statement then
this may have any number of defer statements.</p>
<h4 id="static-and-tlocal-variables-in-defer">Static and tlocal variables in defer</h4>
<p>Static and tlocal variables are allowed in a defer statement. Only a single variable is instantiated regardless of
the number of inlining locations.</p>
<h4 id="defer-and-return">Defer and return</h4>
<p>If the <code>return</code> has an expression, then it is evaluated before the defer statements (due to exit from the current
function scope),
are executed.</p>
<p>Example:</p>
<pre><code class="language-c">int a = 0;
defer a++;
return a;
// This is equivalent to
int a = 0;
int temp = a;
a++;
return temp;
</code></pre>
<h4 id="defer-and-jump-statements">Defer and jump statements</h4>
<p>A defer body may not contain a <code>break</code>, <code>continue</code>, <code>return</code> or rethrow that would exit the statement.</p>
<h4 id="defer-execution">Defer execution</h4>
<p>Defer statements are executed in the reverse order of their declaration, starting from the last declared
defer statement.</p>
<h4 id="defer-try">Defer try</h4>
<p>A <code>defer try</code> type of defer will only execute if the scope is left through normal fallthrough, <code>break</code>,
<code>continue</code> or a <code>return</code> with a result.</p>
<p>It will not execute if the exit is through a rethrow or a <code>return</code> with an optional value.</p>
<h4 id="defer-catch">Defer catch</h4>
<p>A <code>defer catch</code> type of defer will only execute if the scope is left through a rethrow or a <code>return</code> with an optional
value</p>
<p>It will not execute if the exit is a normal fallthrough, <code>break</code>, <code>continue</code> or a <code>return</code> with a result.</p>
<h4 id="non-regular-returns-longjmp-panic-and-other-errors">Non-regular returns - longjmp, panic and other errors</h4>
<p>Defers will not execute when doing <code>longjmp</code> terminating through a <code>panic</code> or other error. They
are only invoked on regular scope exits.</p>
<h3 id="expr-statement">Expr statement</h3>
<p>An expression statement evaluates an expression.</p>
<pre><code>expr_stmt          ::= expr &quot;;&quot;
</code></pre>
<h4 id="no-discard">No discard</h4>
<p>If the expression is a function or macro call either returning an optional <em>or</em> annotated <code>@nodiscard</code>, then
the expression is a compile time error. A function or macro returning an optional can use the <code>@maydiscard</code>
attribute to suppress this error.</p>
<h3 id="if-statement">If statement</h3>
<p>An if statement will evaluate the cond expression, then execute the first statement (the "then clause") in the if-body
if it evaluates to "true", otherwise execute the else clause. If no else clause exists, then the
next statement is executed.</p>
<pre><code>if_stmt            ::= &quot;if&quot; (label &quot;:&quot;)? &quot;(&quot; cond_expr &quot;)&quot; if_body
if_body            ::= non_compound_stmt | compound_stmt else_clause? | &quot;{&quot; switch_body &quot;}&quot;
else_clause        ::= &quot;else&quot; (if_stmt | compound_stmt)

</code></pre>
<h4 id="scopes_2">Scopes</h4>
<p>Both the "then" clause and the else clause open new scopes, even if they are non-compound statements.
The cond expression scope is valid until the exit of the entire statement, so any declarations in the
cond expression are available both in then and else clauses. Declarations in the "then" clause is not available
in the else clause and vice versa.</p>
<h4 id="special-parsing-of-the-then-clause">Special parsing of the "then" clause</h4>
<p>If the then-clause isn't a compound statement, then it must follow on the same row as the cond expression.
It may not appear on a consecutive row.</p>
<h4 id="break">Break</h4>
<p>It is possible to use labelled break to break out of an if statement. Note that an unlabelled <code>break</code> may not
be used.</p>
<h4 id="if-try">If-try</h4>
<p>The cond expression may be a try-unwrap chain. In this case, the unwrapped variables are
scoped to the "then" clause only.</p>
<h4 id="if-catch">If-catch</h4>
<p>The cond expression may be a catch-unwrap. The unwrap is scoped to the "then" clause only.
If one or more variables are in the catch, then the "else" clause have these variables
implicitly unwrapped.</p>
<p>Example:</p>
<pre><code>int! a = foo();
int! b = foo();
if (catch a, b)
{
    // Do something
}
else
{
    int x = a + b; // Valid, a and b are implicitly unwrapped.
}  
</code></pre>
<h4 id="if-catch-implicit-unwrap">If-catch implicit unwrap</h4>
<p>If an if-catch's "then"-clause will jump out of the outer scope in all code paths and
the catch is on one or more variables, then this variable(s) will be implicitly unwrapped in the outer scope
after the if-statement.</p>
<p>Example:</p>
<pre><code>int! a = foo();
if (catch a)
{
  return;
}  
int x = a; // Valid, a is implicitly unwrapped.
</code></pre>
<h3 id="nextcase-statement">Nextcase statement</h3>
<p>Nextcase will jump to another <code>switch</code> case.</p>
<pre><code>nextcase_stmt      ::= &quot;nextcase&quot; ((label &quot;:&quot;)? (expr | &quot;default&quot;))? &quot;;&quot; 
</code></pre>
<h4 id="labels">Labels</h4>
<p>When a nextcase has a label, the jump is to the switch in an outer scope with the corresponding label.</p>
<h4 id="no-expression-jumps">No expression jumps</h4>
<p>A <code>nextcase</code> without any expression jumps to the next case clause in the current switch. It is not possible
to use no expression <code>nextcase</code> with labels.</p>
<h4 id="jumps-to-default">Jumps to default</h4>
<p>Using <code>default</code> jumps to the default clause of a switch.</p>
<h4 id="missing-case">Missing case</h4>
<p>If the switch has constant case values, and the nextcase expression is constant, then the value of
the expression must match a case clause. Not matching a case is a compile time error.</p>
<p>If one or more cases are non-constant and/or the nextcase expression is non-constant, then no compile time check is
made.</p>
<h4 id="variable-expression">Variable expression</h4>
<p>If the nextcase has a non-constant expression, or the cases are not all constant, then first the nextcase expression
is evaluated. Next, execution will proceed <em>as if</em> the switch was invoked again, but with the nextcase expression as the
switch cond expression. See <strong>switch statement</strong>.</p>
<p>If the switch does not have a cond expression, nextcase with an expression is not allowed.</p>
<h4 id="unreachable-code_2">Unreachable code</h4>
<p>Any statement in the same scope after a <code>nextcase</code> are considered <strong>unreachable</strong>.</p>
<h3 id="switch-statement">Switch statement</h3>
<pre><code>switch_stmt        ::= &quot;switch&quot; (label &quot;:&quot;)? (&quot;(&quot; cond_expr &quot;)&quot;)? switch body
switch_body        ::= &quot;{&quot; case_clause* &quot;}&quot;
case_clause        ::= default_stmt | case_stmt
default_stmt       ::= &quot;default&quot; &quot;:&quot; stmt*
case_stmt          ::= &quot;case&quot; label? expr (&quot;..&quot; expr)? &quot;:&quot; stmt*
</code></pre>
<h4 id="regular-switch">Regular switch</h4>
<p>If the cond expression exists and all case statements have constant expression, then first the
cond expression is evaluated, next the case corresponding to the expression's value will be jumped to
and the statement will be executed. After reaching the end of the statements and a new case clause <em>or</em> the
end of the switch body, the execution will jump to the first statement after the switch.</p>
<h4 id="if-switch">If-switch</h4>
<p>If the cond expression is missing or the case statements are non-constant expressions, then each case clause will
be evaluated in order after the cond expression has been evaluated (if it exists):</p>
<ol>
<li>If a cond expression exists, calculate the case expression and execute the case if it is matching the
   cond expression. A default statement has no expression and will always be considered matching the cond expression
   reached.</li>
<li>If no con expression exists, calculate the case expression and execute the case if the expression evaluates to
   "true" when implicitly converted to boolean. A default statement will always be considered having the "true" result.</li>
</ol>
<h4 id="any-switch">Any-switch</h4>
<p>If the cond expression is an <code>any*</code> type, the switch is handled as if switching was done over the <code>type</code>
field of the <code>any*</code>. This field has the type of <a href="#typeid-type">typeid</a>, and the cases follows the rules
for <a href="#switching-over-typeid">switching over typeid</a>.</p>
<p>If the cond expression is a variable, then this variable is implicitly converted to a pointer with
the pointee type given by the case statement.</p>
<p>Example:</p>
<pre><code class="language-c">any* a = abc();
switch (a)
{
    case int:
        int b = *a;   // a is int*
    case float:
        float z = *a; // a is float*
    case Bar:
        Bar f = *a;   // a is Bar*
    default:
        // a is not unwrapped
}              
</code></pre>
<h4 id="ranged-cases_1">Ranged cases</h4>
<p>Cases may be ranged. The start and end of the range must both be constant integer values. The start must
be less or equal to the end value. Using non-integers or non-constant values is a compile time error.</p>
<h4 id="fallthrough_1">Fallthrough</h4>
<p>If a case clause has no statements, then when executing the case, rather than exiting the switch, the next case clause
immediately following it will be executed. If that one should also be missing statement, the procedure
will be repeated until a case clause with statements is encountered (and executed), or the end of the switch is reached.</p>
<h4 id="exhaustive-switch">Exhaustive switch</h4>
<p>If a switch case has a default clause <em>or</em> it is switching over an enum and there exists a case for each enum value
then the switch is exhaustive.</p>
<h4 id="break_1">Break</h4>
<p>If an unlabelled break, or a break with the switch's label is encountered,
then the execution will jump out of the switch and proceed directly after the end of the switch body.</p>
<h4 id="unreachable-code_3">Unreachable code</h4>
<p>If a switch is exhaustive and all case clauses end with a jump instruction, containing no break statement out
of the current switch, then the code directly following the switch will be considered <strong>unreachable</strong>.</p>
<h4 id="switching-over-typeid">Switching over typeid</h4>
<p>If the switch cond expression is a typeid, then case declarations may use only the type name after the case,
which will be interpreted as having an implicit <code>.typeid</code>. Example: <code>case int:</code> will be interpreted as if
written <code>case int.typeid</code>.</p>
<h4 id="nextcase-without-expression">Nextcase without expression</h4>
<p>Without a value <code>nextcase</code> will jump to the beginning of the next case clause. It is not allowed to
put <code>nextcase</code> without an expression if there are no following case clauses.</p>
<h4 id="nextcase-with-expression">Nextcase with expression</h4>
<p>Nextcase with an expression will evaluate the expression and then jump <em>as if</em> the switch was entered with
the cond expression corresponding to the value of the nextcase expression. Nextcase with an expression cannot
be used on a switch without a cond expression.</p>
<h4 id="do-statement">Do statement</h4>
<p>The do statement first evaluates its body (inner statement), then evaluates the cond expression.
If the cond expression evaluates to true, jumps back into the body and repeats the process.</p>
<pre><code>do_stmt            ::= &quot;do&quot; label? compound_stmt (&quot;while&quot; &quot;(&quot; cond_expr &quot;)&quot;)? &quot;;&quot; 
</code></pre>
<h4 id="unreachable-code_4">Unreachable code</h4>
<p>The statement after a <code>do</code> is considered unreachable if the cond expression cannot ever be false
and there is no <code>break</code> out of the do.</p>
<h4 id="break_2">Break</h4>
<p><code>break</code> will exit the do with execution continuing on the following statement.</p>
<h4 id="continue">Continue</h4>
<p><code>continue</code> will jump directly to the evaluation of the cond, as if the end of the statement had been reached.</p>
<h4 id="do-block">Do block</h4>
<p>If no <code>while</code> part exists, it will only execute the block once, as if it ended with <code>while (false)</code>, this is
called a "do block"</p>
<h3 id="for-statement">For statement</h3>
<p>The <code>for</code> statement will perform the (optional) init expression. The cond expression will then be tested. If
it evaluates to <code>true</code> then the body will execute, followed by the incr expression. After execution will
jump back to the cond expression and execution will repeat until the cond expression evaluates to <code>false</code>.</p>
<pre><code>for_stmt           ::= &quot;for&quot; label? &quot;(&quot; init_expr &quot;;&quot; cond_expr? &quot;;&quot; incr_expr &quot;)&quot; stmt
init_expr          ::= decl_expr_list?
incr_expr          ::= expr_list? 
</code></pre>
<h4 id="init-expression">Init expression</h4>
<p>The init expression is only executed once before the rest of the for loop is executed.
Any declarations in the init expression will be in scope until the for loop exits.</p>
<p>The init expression may optionally be omitted.</p>
<h4 id="incr-expression">Incr expression</h4>
<p>The incr expression is evaluated before evaluating the cond expr every time except for the first one.</p>
<p>The incr expression may optionally be omitted.</p>
<h4 id="cond-expression_1">Cond expression</h4>
<p>The cond expression is evaluated every loop. Any declaration in the cond expression is scoped to the
current loop, i.e. it will be reinitialized at the start of every loop.</p>
<p>The cond expression may optionally be omitted. This is equivalent to setting the cond expression to
always return <code>true</code>.</p>
<h4 id="unreachable-code_5">Unreachable code</h4>
<p>The statement after a <code>for</code> is considered unreachable if the cond expression cannot ever be false, or is
omitted and there is no <code>break</code> out of the loop.</p>
<h4 id="break_3">Break</h4>
<p><code>break</code> will exit the <code>for</code> with execution continuing on the following statement after the <code>for</code>.</p>
<h4 id="continue_1">Continue</h4>
<p><code>continue</code> will jump directly to the evaluation of the cond, as if the end of the statement had been reached.</p>
<h4 id="equivalence-of-while-and-for">Equivalence of <code>while</code> and <code>for</code></h4>
<p>A <code>while</code> loop is functionally equivalent to a <code>for</code> loop without init and incr expressions.</p>
<h3 id="foreach-and-foreach_r-statements">Foreach and foreach_r statements</h3>
<p>The <code>foreach</code> statement will loop over a sequence of values. The <code>foreach_r</code> is equivalent to
<code>foreach</code> but the order of traversal is reversed.
<code>foreach</code> starts with element <code>0</code> and proceeds step by step to element <code>len - 1</code>.
<code>foreach_r</code> starts starts with element <code>len - 1</code> and proceeds step by step to element <code>0</code>.</p>
<pre><code>foreach_stmt       ::= &quot;foreach&quot; label? &quot;(&quot; foreach_vars &quot;:&quot; expr &quot;)&quot; stmt
foreach_r_stmt     ::= &quot;foreach_r&quot; label? &quot;(&quot; foreach_vars &quot;:&quot; expr &quot;)&quot; stmt
foreach_vars       ::= (foreach_index &quot;,&quot;)? foreach_var
foreach_var        ::= type? &quot;&amp;&quot;? IDENTIFIER
</code></pre>
<h4 id="break_4">Break</h4>
<p><code>break</code> will exit the foreach statement with execution continuing on the following statement after.</p>
<h4 id="continue_2">Continue</h4>
<p><code>continue</code> will cause the next iteration to commence, as if the end of the statement had been reached.</p>
<h4 id="iteration-by-value-or-reference">Iteration by value or reference</h4>
<p>Normally iteration are by value. Each element is copied into the foreach variable. If <code>&amp;</code>
is added before the variable name, the elements will be retrieved by reference instead, and consequently
the type of the variable will be a pointer to the element type instead.</p>
<h4 id="foreach-variable">Foreach variable</h4>
<p>The foreach variable may omit the type. In this case the type is inferred. If the type differs from the element
type, then an implicit conversion will be attempted. Failing this is a compile time error.</p>
<h4 id="foreach-index">Foreach index</h4>
<p>If a variable name is added before the foreach variable, then this variable will receive the index of the element.
For <code>foreach_r</code> this mean that the first value of the index will be <code>len - 1</code>.</p>
<p>The index type defaults to <code>usz</code>.</p>
<p>If an optional type is added to the index, the index will be converted to this type. The type must be an
integer type. The conversion happens as if the conversion was a direct cast. If the actual index value
would exceed the maximum representable value of the type, this does not affect the actual iteration, but
may cause the index value to take on an incorrect value due to the cast.</p>
<p>For example, if the optional index type is <code>char</code> and the actual index is <code>256</code>, then the index value would show <code>0</code>
as <code>(char)256</code> evaluates to zero.</p>
<p>Modifying the index variable will not affect the foreach iteration.</p>
<h4 id="foreach-support">Foreach support</h4>
<p>Foreach is natively supported for any subarray, array, pointer to an array, vector and pointer to a vector.
These types support both iteration by value and reference.</p>
<p>In addition, a type with <strong>operator overload</strong> for <code>len</code> and <code>[]</code> will support iteration by value,
and a type with <strong>operator overload</strong> for <code>len</code> and <code>&amp;[]</code> will support iteration by reference.</p>
<h3 id="return-statement">Return statement</h3>
<p>The return statement evaluates its expression (if present) and returns the result.</p>
<pre><code>return_stmt        ::= &quot;return&quot; expr? &quot;;&quot;
</code></pre>
<h4 id="jumps-in-return-statements">Jumps in return statements</h4>
<p>If the expression should in itself cause an implicit return, for example due to the rethrow operator <code>!</code>, then this
jump will happen before the return.</p>
<p>An example:</p>
<pre><code>return foo()!;
// is equivalent to:
int temp = foo()!;
return temp;
</code></pre>
<h4 id="return-from-expression-blocks">Return from expression blocks</h4>
<p>A <code>return</code> from an expression block only returns out of the expression block, it never returns from the
expression block's enclosing scope.</p>
<h4 id="empty-returns">Empty returns</h4>
<p>An empty return is equivalent to a return with a void type. Consequently constructs like <code>foo(); return;</code>
and <code>return (void)foo();</code>
are equivalent.</p>
<h4 id="unreachable-code_6">Unreachable code</h4>
<p>Any statement directly following a return in the same scope are considered unreachable.</p>
<h3 id="while-statement">While statement</h3>
<p>The while statement evaluates the cond expression and executes the statement if it evaluates to true.
After this the cond expression is evaluated again and the process is repeated until cond expression returns false.</p>
<pre><code>while_stmt         ::= &quot;while&quot; label? &quot;(&quot; cond_expr &quot;)&quot; stmt
</code></pre>
<h4 id="unreachable-code_7">Unreachable code</h4>
<p>The statement after a while is considered unreachable if the cond expression cannot ever be false
and there is no <code>break</code> out of the while.</p>
<h4 id="break_5">Break</h4>
<p><code>break</code> will exit the while with execution continuing on the following statement.</p>
<h4 id="continue_3">Continue</h4>
<p><code>continue</code> will jump directly to the evaluation of the cond, as if the end of the statement had been reached.</p>
<h3 id="var-statement">Var statement</h3>
<p>A var statement declares a variable with inferred type, or a compile time type variable. It can be used both
for runtime and compile time variables. The use for runtime variables is limited to macros.</p>
<pre><code>var_stmt           ::= &quot;var&quot; IDENTIFIER | CT_IDENT | CT_TYPE_IDENT (&quot;=&quot; expr)? &quot;;&quot; 
</code></pre>
<h4 id="inferring-type">Inferring type</h4>
<p>In the case of a runtime variable, the type is inferred from the expression. Not providing an expression
is a compile time error. The expression must resolve to a runtime type.</p>
<p>For compile time variables, the expression is optional. The expression may resolve to a runtime or compile time type.</p>
<h4 id="scope">Scope</h4>
<p>Runtime variables will follow the runtime scopes, identical to behaviour in a declaration statement. The compile
time variables will follow the compile time scopes which are delimited by scoping compile time
statements (<code>$if</code>, <code>$switch</code>,
<code>$foreach</code> and <code>$for</code>).</p>
<h2 id="attributes">Attributes</h2>
<p>Attributes are modifiers attached to modules, variables, type declarations etc.</p>
<table>
<thead>
<tr>
<th>name</th>
<th>used with</th>
</tr>
</thead>
<tbody>
<tr>
<td>@align</td>
<td>fn, const, variables, user-defined types, struct member</td>
</tr>
<tr>
<td>@benchmark</td>
<td>module, fn</td>
</tr>
<tr>
<td>@bigendian</td>
<td>bitstruct only</td>
</tr>
<tr>
<td>@builtin</td>
<td>macro, fn, global, constant</td>
</tr>
<tr>
<td>@callconv</td>
<td>fn, call</td>
</tr>
<tr>
<td>@deprecated</td>
<td>fn, macro, variables, constants, user-defined types, struct member</td>
</tr>
<tr>
<td>@dynamic</td>
<td>fn</td>
</tr>
<tr>
<td>@export</td>
<td>fn, globals, constants, struct, union, enum, fault</td>
</tr>
<tr>
<td>@extern</td>
<td>fn, globals, constants, user-defined types</td>
</tr>
<tr>
<td>@if</td>
<td>all except local variables and calls</td>
</tr>
<tr>
<td>@inline</td>
<td>fn, call</td>
</tr>
<tr>
<td>@interface</td>
<td>fn</td>
</tr>
<tr>
<td>@littleendian</td>
<td>bitstruct only</td>
</tr>
<tr>
<td>@local</td>
<td>module, fn, macro, globals, constants, user-defined types, attributes and aliases</td>
</tr>
<tr>
<td>@maydiscard</td>
<td>fn, macro</td>
</tr>
<tr>
<td>@naked</td>
<td>fn</td>
</tr>
<tr>
<td>@nodiscard</td>
<td>fn, macro</td>
</tr>
<tr>
<td>@noinit</td>
<td>variables</td>
</tr>
<tr>
<td>@noinline</td>
<td>fn, call</td>
</tr>
<tr>
<td>@noreturn</td>
<td>fn, macro</td>
</tr>
<tr>
<td>@nostrip</td>
<td>fn, globals, constants, struct, union, enum, fault</td>
</tr>
<tr>
<td>@obfuscate</td>
<td>enum, fault</td>
</tr>
<tr>
<td>@operator</td>
<td>fn, macro</td>
</tr>
<tr>
<td>@overlap</td>
<td>bitstruct only</td>
</tr>
<tr>
<td>@packed</td>
<td>struct, union</td>
</tr>
<tr>
<td>@priority</td>
<td>initializer/finalizer</td>
</tr>
<tr>
<td>@private</td>
<td>module, fn, macro, globals, constants, user-defined types, attributes and aliases</td>
</tr>
<tr>
<td>@public</td>
<td>module, fn, macro, globals, constants, user-defined types, attributes and aliases</td>
</tr>
<tr>
<td>@pure</td>
<td>call</td>
</tr>
<tr>
<td>@reflect</td>
<td>fn, globals, constants, user-defined types</td>
</tr>
<tr>
<td>@section</td>
<td>fn, globals, constants</td>
</tr>
<tr>
<td>@test</td>
<td>module, fn</td>
</tr>
<tr>
<td>@unused</td>
<td>all except call and initializer/finalizers</td>
</tr>
<tr>
<td>@used</td>
<td>all except call and initializer/finalizers</td>
</tr>
<tr>
<td>@weak</td>
<td>fn, globals, constants</td>
</tr>
<tr>
<td>@winmain</td>
<td>fn</td>
</tr>
</tbody>
</table>
<h3 id="user-defined-attributes">User defined attributes</h3>
<p>User defined attributes group a list of attributes.</p>
<pre><code>attribute_decl     ::= &quot;def&quot; AT_TYPE_IDENT (&quot;(&quot; parameters &quot;)&quot;)? attribute* &quot;=&quot; &quot;{&quot; attribute* &quot;}&quot; &quot;;&quot; 
</code></pre>
<h4 id="empty-list-of-attributes">Empty list of attributes</h4>
<p>The list of attributes may be empty.</p>
<h4 id="parameter-arguments">Parameter arguments</h4>
<p>Arguments given to user defined attributes will be passed on to the attributes in the list.</p>
<h4 id="expansion">Expansion</h4>
<p>When a user defined attribute is encountered, its list of attributes is
copied and appended instead of the user defined attribute. Any argument passed to 
the attribute is evaluated and passed as a constant by the name of the parameter
to the evaluation of the attribute parameters in the list.</p>
<h4 id="nesting">Nesting</h4>
<p>A user defined attribute can contain other user defined attributes. The definition
may not be cyclic.</p>
<h2 id="modules">Modules</h2>
<p>Module paths are hierarchal, with each sub-path appended with '::' + the name:</p>
<pre><code>path               ::= PATH_SEGMENT (&quot;::&quot; PATH_SEGMENT)
</code></pre>
<p>Each module declaration starts its own <strong>module section</strong>. All imports and all <code>@local</code> declarations
are only visible in the current <strong>module section</strong>.</p>
<pre><code>module_section     ::= &quot;module&quot; path opt_generic_params? attributes? &quot;;&quot;
generic_param      ::= TYPE_IDENT | CONST_IDENT
opt_generic_params ::= &quot;(&lt;&quot; generic_param (&quot;,&quot; generic_param)* &quot;&gt;)&quot;
</code></pre>
<p>Any visibility attribute defined in a <strong>module section</strong> will be the default visibility in all
declarations in the section.</p>
<p>If the <code>@benchmark</code> attribute is applied to the <strong>module section</strong> then all function declarations
will implicitly have the <code>@benchmark</code> attribute.</p>
<p>If the <code>@test</code> attribute is applied to the <strong>module section</strong> then all function declarations
will implicitly have the <code>@test</code> attribute.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../buildintro/" class="btn btn-neutral float-right" title="Introduction">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../sample/" class="btn btn-neutral" title="More code examples"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../sample/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../buildintro/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
